// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: currency.sql

package db

import (
	"context"
	"database/sql"
)

const changeCurrencyActiveState = `-- name: ChangeCurrencyActiveState :one
UPDATE currencies SET active = $1, can_have_wallet = $1, can_swap_from = $1, can_swap_to = $1  WHERE id = $2 RETURNING id, name, decimal_places, active, can_have_wallet, can_swap_from, can_swap_to, code, supported_payment_schemes
`

type ChangeCurrencyActiveStateParams struct {
	Active bool  `json:"active"`
	ID     int32 `json:"id"`
}

func (q *Queries) ChangeCurrencyActiveState(ctx context.Context, arg ChangeCurrencyActiveStateParams) (Currency, error) {
	row := q.db.QueryRowContext(ctx, changeCurrencyActiveState, arg.Active, arg.ID)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DecimalPlaces,
		&i.Active,
		&i.CanHaveWallet,
		&i.CanSwapFrom,
		&i.CanSwapTo,
		&i.Code,
		&i.SupportedPaymentSchemes,
	)
	return i, err
}

const createCurrency = `-- name: CreateCurrency :one
INSERT INTO currencies (name, code, decimal_places, can_have_wallet, can_swap_from, can_swap_to, supported_payment_schemes,active)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, name, decimal_places, active, can_have_wallet, can_swap_from, can_swap_to, code, supported_payment_schemes
`

type CreateCurrencyParams struct {
	Name                    string `json:"name"`
	Code                    string `json:"code"`
	DecimalPlaces           int16  `json:"decimal_places"`
	CanHaveWallet           bool   `json:"can_have_wallet"`
	CanSwapFrom             bool   `json:"can_swap_from"`
	CanSwapTo               bool   `json:"can_swap_to"`
	SupportedPaymentSchemes string `json:"supported_payment_schemes"`
	Active                  bool   `json:"active"`
}

func (q *Queries) CreateCurrency(ctx context.Context, arg CreateCurrencyParams) (Currency, error) {
	row := q.db.QueryRowContext(ctx, createCurrency,
		arg.Name,
		arg.Code,
		arg.DecimalPlaces,
		arg.CanHaveWallet,
		arg.CanSwapFrom,
		arg.CanSwapTo,
		arg.SupportedPaymentSchemes,
		arg.Active,
	)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DecimalPlaces,
		&i.Active,
		&i.CanHaveWallet,
		&i.CanSwapFrom,
		&i.CanSwapTo,
		&i.Code,
		&i.SupportedPaymentSchemes,
	)
	return i, err
}

const deleteCurrency = `-- name: DeleteCurrency :exec
DELETE FROM currencies WHERE id = $1
`

func (q *Queries) DeleteCurrency(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteCurrency, id)
	return err
}

const getActiveCurrencies = `-- name: GetActiveCurrencies :many
SELECT id, name, decimal_places, active, can_have_wallet, can_swap_from, can_swap_to, code, supported_payment_schemes FROM currencies
         WHERE active = COALESCE($1, active)
         ORDER BY name ASC
`

func (q *Queries) GetActiveCurrencies(ctx context.Context, active sql.NullBool) ([]Currency, error) {
	rows, err := q.db.QueryContext(ctx, getActiveCurrencies, active)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Currency{}
	for rows.Next() {
		var i Currency
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DecimalPlaces,
			&i.Active,
			&i.CanHaveWallet,
			&i.CanSwapFrom,
			&i.CanSwapTo,
			&i.Code,
			&i.SupportedPaymentSchemes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCurrencies = `-- name: GetAllCurrencies :many
SELECT id, name, decimal_places, active, can_have_wallet, can_swap_from, can_swap_to, code, supported_payment_schemes FROM currencies
         ORDER BY name ASC
`

func (q *Queries) GetAllCurrencies(ctx context.Context) ([]Currency, error) {
	rows, err := q.db.QueryContext(ctx, getAllCurrencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Currency{}
	for rows.Next() {
		var i Currency
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DecimalPlaces,
			&i.Active,
			&i.CanHaveWallet,
			&i.CanSwapFrom,
			&i.CanSwapTo,
			&i.Code,
			&i.SupportedPaymentSchemes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrency = `-- name: GetCurrency :one
SELECT id, name, decimal_places, active, can_have_wallet, can_swap_from, can_swap_to, code, supported_payment_schemes FROM currencies WHERE id = $1 LIMIT  1
`

func (q *Queries) GetCurrency(ctx context.Context, id int32) (Currency, error) {
	row := q.db.QueryRowContext(ctx, getCurrency, id)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DecimalPlaces,
		&i.Active,
		&i.CanHaveWallet,
		&i.CanSwapFrom,
		&i.CanSwapTo,
		&i.Code,
		&i.SupportedPaymentSchemes,
	)
	return i, err
}

const getCurrencyByCode = `-- name: GetCurrencyByCode :one
SELECT id, name, decimal_places, active, can_have_wallet, can_swap_from, can_swap_to, code, supported_payment_schemes FROM currencies WHERE code = $1 LIMIT  1
`

func (q *Queries) GetCurrencyByCode(ctx context.Context, code string) (Currency, error) {
	row := q.db.QueryRowContext(ctx, getCurrencyByCode, code)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DecimalPlaces,
		&i.Active,
		&i.CanHaveWallet,
		&i.CanSwapFrom,
		&i.CanSwapTo,
		&i.Code,
		&i.SupportedPaymentSchemes,
	)
	return i, err
}

const updateCurrency = `-- name: UpdateCurrency :one
UPDATE currencies
SET name = COALESCE($1, name),
    code = COALESCE($2, code),
    decimal_places = COALESCE($3, decimal_places),
    can_have_wallet = COALESCE($4, can_have_wallet),
    can_swap_from = COALESCE($5, can_swap_from),
    can_swap_to = COALESCE($6, can_swap_to),
    supported_payment_schemes = COALESCE($7, supported_payment_schemes),
    active = COALESCE($8, active)
WHERE id = $9 RETURNING id, name, decimal_places, active, can_have_wallet, can_swap_from, can_swap_to, code, supported_payment_schemes
`

type UpdateCurrencyParams struct {
	Name                    sql.NullString `json:"name"`
	Code                    sql.NullString `json:"code"`
	DecimalPlaces           sql.NullInt16  `json:"decimal_places"`
	CanHaveWallet           sql.NullBool   `json:"can_have_wallet"`
	CanSwapFrom             sql.NullBool   `json:"can_swap_from"`
	CanSwapTo               sql.NullBool   `json:"can_swap_to"`
	SupportedPaymentSchemes sql.NullString `json:"supported_payment_schemes"`
	Active                  sql.NullBool   `json:"active"`
	ID                      int32          `json:"id"`
}

func (q *Queries) UpdateCurrency(ctx context.Context, arg UpdateCurrencyParams) (Currency, error) {
	row := q.db.QueryRowContext(ctx, updateCurrency,
		arg.Name,
		arg.Code,
		arg.DecimalPlaces,
		arg.CanHaveWallet,
		arg.CanSwapFrom,
		arg.CanSwapTo,
		arg.SupportedPaymentSchemes,
		arg.Active,
		arg.ID,
	)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DecimalPlaces,
		&i.Active,
		&i.CanHaveWallet,
		&i.CanSwapFrom,
		&i.CanSwapTo,
		&i.Code,
		&i.SupportedPaymentSchemes,
	)
	return i, err
}
