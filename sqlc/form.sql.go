// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: form.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const createDynamicOption = `-- name: CreateDynamicOption :one
INSERT INTO form_dynamic_options (
    id, name, source_type, source_config, cache_duration
) VALUES (
             $1, $2, $3, $4, $5
         ) RETURNING id, name, source_type, source_config, cache_duration, created_at
`

type CreateDynamicOptionParams struct {
	ID            uuid.UUID       `json:"id"`
	Name          string          `json:"name"`
	SourceType    string          `json:"source_type"`
	SourceConfig  json.RawMessage `json:"source_config"`
	CacheDuration int32           `json:"cache_duration"`
}

func (q *Queries) CreateDynamicOption(ctx context.Context, arg CreateDynamicOptionParams) (FormDynamicOption, error) {
	row := q.db.QueryRowContext(ctx, createDynamicOption,
		arg.ID,
		arg.Name,
		arg.SourceType,
		arg.SourceConfig,
		arg.CacheDuration,
	)
	var i FormDynamicOption
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SourceType,
		&i.SourceConfig,
		&i.CacheDuration,
		&i.CreatedAt,
	)
	return i, err
}

const createFormAssignment = `-- name: CreateFormAssignment :one
INSERT INTO form_assignments (
    id, form_definition_id, assignment_type, assignment_value,
    conditions, priority, valid_from, valid_until, created_by
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9
         ) RETURNING id, form_definition_id, assignment_type, assignment_value, conditions, priority, valid_from, valid_until, created_at, created_by
`

type CreateFormAssignmentParams struct {
	ID               uuid.UUID             `json:"id"`
	FormDefinitionID uuid.UUID             `json:"form_definition_id"`
	AssignmentType   string                `json:"assignment_type"`
	AssignmentValue  string                `json:"assignment_value"`
	Conditions       pqtype.NullRawMessage `json:"conditions"`
	Priority         int32                 `json:"priority"`
	ValidFrom        sql.NullTime          `json:"valid_from"`
	ValidUntil       sql.NullTime          `json:"valid_until"`
	CreatedBy        uuid.NullUUID         `json:"created_by"`
}

func (q *Queries) CreateFormAssignment(ctx context.Context, arg CreateFormAssignmentParams) (FormAssignment, error) {
	row := q.db.QueryRowContext(ctx, createFormAssignment,
		arg.ID,
		arg.FormDefinitionID,
		arg.AssignmentType,
		arg.AssignmentValue,
		arg.Conditions,
		arg.Priority,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.CreatedBy,
	)
	var i FormAssignment
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.AssignmentType,
		&i.AssignmentValue,
		&i.Conditions,
		&i.Priority,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createFormDefinition = `-- name: CreateFormDefinition :one
INSERT INTO form_definitions (
    id, name, slug, description, form_type, version, is_active,
    is_multi_step, requires_approval, approval_workflow, is_editable_after_submission, created_by
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
         ) RETURNING id, name, slug, description, form_type, version, is_active, is_multi_step, requires_approval, is_editable_after_submission, approval_workflow, created_at, updated_at, created_by
`

type CreateFormDefinitionParams struct {
	ID                        uuid.UUID       `json:"id"`
	Name                      string          `json:"name"`
	Slug                      string          `json:"slug"`
	Description               string          `json:"description"`
	FormType                  string          `json:"form_type"`
	Version                   int32           `json:"version"`
	IsActive                  bool            `json:"is_active"`
	IsMultiStep               bool            `json:"is_multi_step"`
	RequiresApproval          bool            `json:"requires_approval"`
	ApprovalWorkflow          json.RawMessage `json:"approval_workflow"`
	IsEditableAfterSubmission bool            `json:"is_editable_after_submission"`
	CreatedBy                 uuid.NullUUID   `json:"created_by"`
}

func (q *Queries) CreateFormDefinition(ctx context.Context, arg CreateFormDefinitionParams) (FormDefinition, error) {
	row := q.db.QueryRowContext(ctx, createFormDefinition,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.FormType,
		arg.Version,
		arg.IsActive,
		arg.IsMultiStep,
		arg.RequiresApproval,
		arg.ApprovalWorkflow,
		arg.IsEditableAfterSubmission,
		arg.CreatedBy,
	)
	var i FormDefinition
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.FormType,
		&i.Version,
		&i.IsActive,
		&i.IsMultiStep,
		&i.RequiresApproval,
		&i.IsEditableAfterSubmission,
		&i.ApprovalWorkflow,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createFormEvent = `-- name: CreateFormEvent :one
INSERT INTO form_events (
    id, form_definition_id, event_type, handler_type, handler_config, is_active
) VALUES (
             $1, $2, $3, $4, $5, $6
         ) RETURNING id, form_definition_id, event_type, handler_type, handler_config, is_active, created_at
`

type CreateFormEventParams struct {
	ID               uuid.UUID       `json:"id"`
	FormDefinitionID uuid.UUID       `json:"form_definition_id"`
	EventType        string          `json:"event_type"`
	HandlerType      string          `json:"handler_type"`
	HandlerConfig    json.RawMessage `json:"handler_config"`
	IsActive         bool            `json:"is_active"`
}

func (q *Queries) CreateFormEvent(ctx context.Context, arg CreateFormEventParams) (FormEvent, error) {
	row := q.db.QueryRowContext(ctx, createFormEvent,
		arg.ID,
		arg.FormDefinitionID,
		arg.EventType,
		arg.HandlerType,
		arg.HandlerConfig,
		arg.IsActive,
	)
	var i FormEvent
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.EventType,
		&i.HandlerType,
		&i.HandlerConfig,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const createFormField = `-- name: CreateFormField :one
INSERT INTO form_fields (
    id, form_definition_id, form_step_id, field_name, field_type,
    label, placeholder, help_text, validation_rules, options,
    display_order, is_required, is_readonly, default_value,
    conditional_logic, file_config
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
         ) RETURNING id, form_definition_id, form_step_id, field_name, field_type, label, placeholder, help_text, validation_rules, options, display_order, is_required, is_readonly, default_value, conditional_logic, file_config, created_at, updated_at
`

type CreateFormFieldParams struct {
	ID               uuid.UUID       `json:"id"`
	FormDefinitionID uuid.UUID       `json:"form_definition_id"`
	FormStepID       uuid.UUID       `json:"form_step_id"`
	FieldName        string          `json:"field_name"`
	FieldType        string          `json:"field_type"`
	Label            json.RawMessage `json:"label"`
	Placeholder      json.RawMessage `json:"placeholder"`
	HelpText         json.RawMessage `json:"help_text"`
	ValidationRules  json.RawMessage `json:"validation_rules"`
	Options          json.RawMessage `json:"options"`
	DisplayOrder     int32           `json:"display_order"`
	IsRequired       bool            `json:"is_required"`
	IsReadonly       bool            `json:"is_readonly"`
	DefaultValue     string          `json:"default_value"`
	ConditionalLogic json.RawMessage `json:"conditional_logic"`
	FileConfig       json.RawMessage `json:"file_config"`
}

func (q *Queries) CreateFormField(ctx context.Context, arg CreateFormFieldParams) (FormField, error) {
	row := q.db.QueryRowContext(ctx, createFormField,
		arg.ID,
		arg.FormDefinitionID,
		arg.FormStepID,
		arg.FieldName,
		arg.FieldType,
		arg.Label,
		arg.Placeholder,
		arg.HelpText,
		arg.ValidationRules,
		arg.Options,
		arg.DisplayOrder,
		arg.IsRequired,
		arg.IsReadonly,
		arg.DefaultValue,
		arg.ConditionalLogic,
		arg.FileConfig,
	)
	var i FormField
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.FormStepID,
		&i.FieldName,
		&i.FieldType,
		&i.Label,
		&i.Placeholder,
		&i.HelpText,
		&i.ValidationRules,
		&i.Options,
		&i.DisplayOrder,
		&i.IsRequired,
		&i.IsReadonly,
		&i.DefaultValue,
		&i.ConditionalLogic,
		&i.FileConfig,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFormStep = `-- name: CreateFormStep :one
INSERT INTO form_steps (
    id, form_definition_id, step_number, name, description, is_optional
) VALUES (
             $1, $2, $3, $4, $5, $6
         ) RETURNING id, form_definition_id, step_number, name, description, is_optional, created_at
`

type CreateFormStepParams struct {
	ID               uuid.UUID `json:"id"`
	FormDefinitionID uuid.UUID `json:"form_definition_id"`
	StepNumber       int32     `json:"step_number"`
	Name             string    `json:"name"`
	Description      string    `json:"description"`
	IsOptional       bool      `json:"is_optional"`
}

func (q *Queries) CreateFormStep(ctx context.Context, arg CreateFormStepParams) (FormStep, error) {
	row := q.db.QueryRowContext(ctx, createFormStep,
		arg.ID,
		arg.FormDefinitionID,
		arg.StepNumber,
		arg.Name,
		arg.Description,
		arg.IsOptional,
	)
	var i FormStep
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.StepNumber,
		&i.Name,
		&i.Description,
		&i.IsOptional,
		&i.CreatedAt,
	)
	return i, err
}

const createFormSubmission = `-- name: CreateFormSubmission :one
INSERT INTO form_submissions (
    id, form_definition_id, user_id, submission_data, status,
    approval_status, approval_notes, approved_by, approved_at, metadata
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
         ) RETURNING id, form_definition_id, user_id, submission_data, status, approval_status, approval_notes, approved_by, approved_at, metadata, created_at, updated_at, current_step_number, completion_percentage
`

type CreateFormSubmissionParams struct {
	ID               uuid.UUID       `json:"id"`
	FormDefinitionID uuid.UUID       `json:"form_definition_id"`
	UserID           uuid.UUID       `json:"user_id"`
	SubmissionData   json.RawMessage `json:"submission_data"`
	Status           string          `json:"status"`
	ApprovalStatus   string          `json:"approval_status"`
	ApprovalNotes    string          `json:"approval_notes"`
	ApprovedBy       uuid.NullUUID   `json:"approved_by"`
	ApprovedAt       time.Time       `json:"approved_at"`
	Metadata         json.RawMessage `json:"metadata"`
}

func (q *Queries) CreateFormSubmission(ctx context.Context, arg CreateFormSubmissionParams) (FormSubmission, error) {
	row := q.db.QueryRowContext(ctx, createFormSubmission,
		arg.ID,
		arg.FormDefinitionID,
		arg.UserID,
		arg.SubmissionData,
		arg.Status,
		arg.ApprovalStatus,
		arg.ApprovalNotes,
		arg.ApprovedBy,
		arg.ApprovedAt,
		arg.Metadata,
	)
	var i FormSubmission
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.UserID,
		&i.SubmissionData,
		&i.Status,
		&i.ApprovalStatus,
		&i.ApprovalNotes,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStepNumber,
		&i.CompletionPercentage,
	)
	return i, err
}

const createFormSubmissionFile = `-- name: CreateFormSubmissionFile :one
INSERT INTO form_submission_files (
    id, form_submission_id, field_name, file_name, file_path,
    file_size, mime_type, bucket, storage_provider
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9
         ) RETURNING id, form_submission_id, field_name, file_name, file_path, file_size, mime_type, bucket, storage_provider, uploaded_at
`

type CreateFormSubmissionFileParams struct {
	ID               uuid.UUID `json:"id"`
	FormSubmissionID uuid.UUID `json:"form_submission_id"`
	FieldName        string    `json:"field_name"`
	FileName         string    `json:"file_name"`
	FilePath         string    `json:"file_path"`
	FileSize         int64     `json:"file_size"`
	MimeType         string    `json:"mime_type"`
	Bucket           string    `json:"bucket"`
	StorageProvider  string    `json:"storage_provider"`
}

func (q *Queries) CreateFormSubmissionFile(ctx context.Context, arg CreateFormSubmissionFileParams) (FormSubmissionFile, error) {
	row := q.db.QueryRowContext(ctx, createFormSubmissionFile,
		arg.ID,
		arg.FormSubmissionID,
		arg.FieldName,
		arg.FileName,
		arg.FilePath,
		arg.FileSize,
		arg.MimeType,
		arg.Bucket,
		arg.StorageProvider,
	)
	var i FormSubmissionFile
	err := row.Scan(
		&i.ID,
		&i.FormSubmissionID,
		&i.FieldName,
		&i.FileName,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.Bucket,
		&i.StorageProvider,
		&i.UploadedAt,
	)
	return i, err
}

const createPersistenceConfig = `-- name: CreatePersistenceConfig :one
INSERT INTO form_persistence_configs (
    id, form_definition_id, persistence_mode, target_configs,
    field_mappings, transformation_rules, validation_hooks
) VALUES (
             $1, $2, $3, $4, $5, $6, $7
         ) RETURNING id, form_definition_id, persistence_mode, target_configs, field_mappings, transformation_rules, validation_hooks, created_at, updated_at
`

type CreatePersistenceConfigParams struct {
	ID                  uuid.UUID       `json:"id"`
	FormDefinitionID    uuid.UUID       `json:"form_definition_id"`
	PersistenceMode     string          `json:"persistence_mode"`
	TargetConfigs       json.RawMessage `json:"target_configs"`
	FieldMappings       json.RawMessage `json:"field_mappings"`
	TransformationRules json.RawMessage `json:"transformation_rules"`
	ValidationHooks     json.RawMessage `json:"validation_hooks"`
}

func (q *Queries) CreatePersistenceConfig(ctx context.Context, arg CreatePersistenceConfigParams) (FormPersistenceConfig, error) {
	row := q.db.QueryRowContext(ctx, createPersistenceConfig,
		arg.ID,
		arg.FormDefinitionID,
		arg.PersistenceMode,
		arg.TargetConfigs,
		arg.FieldMappings,
		arg.TransformationRules,
		arg.ValidationHooks,
	)
	var i FormPersistenceConfig
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.PersistenceMode,
		&i.TargetConfigs,
		&i.FieldMappings,
		&i.TransformationRules,
		&i.ValidationHooks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createStepProgress = `-- name: CreateStepProgress :one
INSERT INTO form_step_progress (
    id, form_submission_id, form_step_id, step_number, status, data
) VALUES (
             $1, $2, $3, $4, $5, $6
         ) RETURNING id, form_submission_id, form_step_id, step_number, status, completed_at, data, created_at, updated_at
`

type CreateStepProgressParams struct {
	ID               uuid.UUID             `json:"id"`
	FormSubmissionID uuid.NullUUID         `json:"form_submission_id"`
	FormStepID       uuid.NullUUID         `json:"form_step_id"`
	StepNumber       int32                 `json:"step_number"`
	Status           sql.NullString        `json:"status"`
	Data             pqtype.NullRawMessage `json:"data"`
}

func (q *Queries) CreateStepProgress(ctx context.Context, arg CreateStepProgressParams) (FormStepProgress, error) {
	row := q.db.QueryRowContext(ctx, createStepProgress,
		arg.ID,
		arg.FormSubmissionID,
		arg.FormStepID,
		arg.StepNumber,
		arg.Status,
		arg.Data,
	)
	var i FormStepProgress
	err := row.Scan(
		&i.ID,
		&i.FormSubmissionID,
		&i.FormStepID,
		&i.StepNumber,
		&i.Status,
		&i.CompletedAt,
		&i.Data,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFormSubmissionFile = `-- name: DeleteFormSubmissionFile :exec
DELETE FROM form_submission_files WHERE id = $1
`

func (q *Queries) DeleteFormSubmissionFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteFormSubmissionFile, id)
	return err
}

const getAllStepProgress = `-- name: GetAllStepProgress :many
SELECT id, form_submission_id, form_step_id, step_number, status, completed_at, data, created_at, updated_at FROM form_step_progress
WHERE form_submission_id = $1
ORDER BY step_number
`

func (q *Queries) GetAllStepProgress(ctx context.Context, formSubmissionID uuid.NullUUID) ([]FormStepProgress, error) {
	rows, err := q.db.QueryContext(ctx, getAllStepProgress, formSubmissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FormStepProgress{}
	for rows.Next() {
		var i FormStepProgress
		if err := rows.Scan(
			&i.ID,
			&i.FormSubmissionID,
			&i.FormStepID,
			&i.StepNumber,
			&i.Status,
			&i.CompletedAt,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDynamicOption = `-- name: GetDynamicOption :one
SELECT id, name, source_type, source_config, cache_duration, created_at FROM form_dynamic_options WHERE id = $1
`

func (q *Queries) GetDynamicOption(ctx context.Context, id uuid.UUID) (FormDynamicOption, error) {
	row := q.db.QueryRowContext(ctx, getDynamicOption, id)
	var i FormDynamicOption
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SourceType,
		&i.SourceConfig,
		&i.CacheDuration,
		&i.CreatedAt,
	)
	return i, err
}

const getDynamicOptionByName = `-- name: GetDynamicOptionByName :one
SELECT id, name, source_type, source_config, cache_duration, created_at FROM form_dynamic_options WHERE name = $1
`

func (q *Queries) GetDynamicOptionByName(ctx context.Context, name string) (FormDynamicOption, error) {
	row := q.db.QueryRowContext(ctx, getDynamicOptionByName, name)
	var i FormDynamicOption
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SourceType,
		&i.SourceConfig,
		&i.CacheDuration,
		&i.CreatedAt,
	)
	return i, err
}

const getFormAssignments = `-- name: GetFormAssignments :many
SELECT fa.id, fa.form_definition_id, fa.assignment_type, fa.assignment_value, fa.conditions, fa.priority, fa.valid_from, fa.valid_until, fa.created_at, fa.created_by, fd.form_type
FROM form_assignments fa
         JOIN form_definitions fd ON fd.id = fa.form_definition_id
WHERE fd.is_active = true
  AND (fa.valid_from IS NULL OR fa.valid_from <= CURRENT_TIMESTAMP)
  AND (fa.valid_until IS NULL OR fa.valid_until > CURRENT_TIMESTAMP)
  AND (
    (fa.assignment_type = 'user_id' AND fa.assignment_value = $1) OR
    (fa.assignment_type = 'user_type' AND fa.assignment_value = $2) OR
    (fa.assignment_type = 'country' AND fa.assignment_value = $3) OR
    (fa.assignment_type = 'state' AND fa.assignment_value = $4) OR
    fa.assignment_type = 'custom'
    )
ORDER BY fa.priority DESC
`

type GetFormAssignmentsParams struct {
	AssignmentValue   string `json:"assignment_value"`
	AssignmentValue_2 string `json:"assignment_value_2"`
	AssignmentValue_3 string `json:"assignment_value_3"`
	AssignmentValue_4 string `json:"assignment_value_4"`
}

type GetFormAssignmentsRow struct {
	ID               uuid.UUID             `json:"id"`
	FormDefinitionID uuid.UUID             `json:"form_definition_id"`
	AssignmentType   string                `json:"assignment_type"`
	AssignmentValue  string                `json:"assignment_value"`
	Conditions       pqtype.NullRawMessage `json:"conditions"`
	Priority         int32                 `json:"priority"`
	ValidFrom        sql.NullTime          `json:"valid_from"`
	ValidUntil       sql.NullTime          `json:"valid_until"`
	CreatedAt        time.Time             `json:"created_at"`
	CreatedBy        uuid.NullUUID         `json:"created_by"`
	FormType         string                `json:"form_type"`
}

func (q *Queries) GetFormAssignments(ctx context.Context, arg GetFormAssignmentsParams) ([]GetFormAssignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFormAssignments,
		arg.AssignmentValue,
		arg.AssignmentValue_2,
		arg.AssignmentValue_3,
		arg.AssignmentValue_4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFormAssignmentsRow{}
	for rows.Next() {
		var i GetFormAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.FormDefinitionID,
			&i.AssignmentType,
			&i.AssignmentValue,
			&i.Conditions,
			&i.Priority,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.FormType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFormDefinition = `-- name: GetFormDefinition :one
SELECT id, name, slug, description, form_type, version, is_active, is_multi_step, requires_approval, is_editable_after_submission, approval_workflow, created_at, updated_at, created_by FROM form_definitions WHERE id = $1
`

func (q *Queries) GetFormDefinition(ctx context.Context, id uuid.UUID) (FormDefinition, error) {
	row := q.db.QueryRowContext(ctx, getFormDefinition, id)
	var i FormDefinition
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.FormType,
		&i.Version,
		&i.IsActive,
		&i.IsMultiStep,
		&i.RequiresApproval,
		&i.IsEditableAfterSubmission,
		&i.ApprovalWorkflow,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getFormDefinitionBySlug = `-- name: GetFormDefinitionBySlug :one
SELECT id, name, slug, description, form_type, version, is_active, is_multi_step, requires_approval, is_editable_after_submission, approval_workflow, created_at, updated_at, created_by FROM form_definitions WHERE slug = $1 AND is_active = true
`

func (q *Queries) GetFormDefinitionBySlug(ctx context.Context, slug string) (FormDefinition, error) {
	row := q.db.QueryRowContext(ctx, getFormDefinitionBySlug, slug)
	var i FormDefinition
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.FormType,
		&i.Version,
		&i.IsActive,
		&i.IsMultiStep,
		&i.RequiresApproval,
		&i.IsEditableAfterSubmission,
		&i.ApprovalWorkflow,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getFormEvents = `-- name: GetFormEvents :many
SELECT id, form_definition_id, event_type, handler_type, handler_config, is_active, created_at FROM form_events
WHERE form_definition_id = $1
  AND event_type = $2
  AND is_active = true
`

type GetFormEventsParams struct {
	FormDefinitionID uuid.UUID `json:"form_definition_id"`
	EventType        string    `json:"event_type"`
}

func (q *Queries) GetFormEvents(ctx context.Context, arg GetFormEventsParams) ([]FormEvent, error) {
	rows, err := q.db.QueryContext(ctx, getFormEvents, arg.FormDefinitionID, arg.EventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FormEvent{}
	for rows.Next() {
		var i FormEvent
		if err := rows.Scan(
			&i.ID,
			&i.FormDefinitionID,
			&i.EventType,
			&i.HandlerType,
			&i.HandlerConfig,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFormFields = `-- name: GetFormFields :many
SELECT id, form_definition_id, form_step_id, field_name, field_type, label, placeholder, help_text, validation_rules, options, display_order, is_required, is_readonly, default_value, conditional_logic, file_config, created_at, updated_at FROM form_fields
WHERE form_definition_id = $1
ORDER BY display_order
`

func (q *Queries) GetFormFields(ctx context.Context, formDefinitionID uuid.UUID) ([]FormField, error) {
	rows, err := q.db.QueryContext(ctx, getFormFields, formDefinitionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FormField{}
	for rows.Next() {
		var i FormField
		if err := rows.Scan(
			&i.ID,
			&i.FormDefinitionID,
			&i.FormStepID,
			&i.FieldName,
			&i.FieldType,
			&i.Label,
			&i.Placeholder,
			&i.HelpText,
			&i.ValidationRules,
			&i.Options,
			&i.DisplayOrder,
			&i.IsRequired,
			&i.IsReadonly,
			&i.DefaultValue,
			&i.ConditionalLogic,
			&i.FileConfig,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFormFieldsByStep = `-- name: GetFormFieldsByStep :many
SELECT id, form_definition_id, form_step_id, field_name, field_type, label, placeholder, help_text, validation_rules, options, display_order, is_required, is_readonly, default_value, conditional_logic, file_config, created_at, updated_at FROM form_fields
WHERE form_step_id = $1
ORDER BY display_order
`

func (q *Queries) GetFormFieldsByStep(ctx context.Context, formStepID uuid.UUID) ([]FormField, error) {
	rows, err := q.db.QueryContext(ctx, getFormFieldsByStep, formStepID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FormField{}
	for rows.Next() {
		var i FormField
		if err := rows.Scan(
			&i.ID,
			&i.FormDefinitionID,
			&i.FormStepID,
			&i.FieldName,
			&i.FieldType,
			&i.Label,
			&i.Placeholder,
			&i.HelpText,
			&i.ValidationRules,
			&i.Options,
			&i.DisplayOrder,
			&i.IsRequired,
			&i.IsReadonly,
			&i.DefaultValue,
			&i.ConditionalLogic,
			&i.FileConfig,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFormSteps = `-- name: GetFormSteps :many
SELECT id, form_definition_id, step_number, name, description, is_optional, created_at FROM form_steps
WHERE form_definition_id = $1
ORDER BY step_number
`

func (q *Queries) GetFormSteps(ctx context.Context, formDefinitionID uuid.UUID) ([]FormStep, error) {
	rows, err := q.db.QueryContext(ctx, getFormSteps, formDefinitionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FormStep{}
	for rows.Next() {
		var i FormStep
		if err := rows.Scan(
			&i.ID,
			&i.FormDefinitionID,
			&i.StepNumber,
			&i.Name,
			&i.Description,
			&i.IsOptional,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFormSubmission = `-- name: GetFormSubmission :one
SELECT id, form_definition_id, user_id, submission_data, status, approval_status, approval_notes, approved_by, approved_at, metadata, created_at, updated_at, current_step_number, completion_percentage FROM form_submissions WHERE id = $1
`

func (q *Queries) GetFormSubmission(ctx context.Context, id uuid.UUID) (FormSubmission, error) {
	row := q.db.QueryRowContext(ctx, getFormSubmission, id)
	var i FormSubmission
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.UserID,
		&i.SubmissionData,
		&i.Status,
		&i.ApprovalStatus,
		&i.ApprovalNotes,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStepNumber,
		&i.CompletionPercentage,
	)
	return i, err
}

const getFormSubmissionByUserAndForm = `-- name: GetFormSubmissionByUserAndForm :one
SELECT id, form_definition_id, user_id, submission_data, status, approval_status, approval_notes, approved_by, approved_at, metadata, created_at, updated_at, current_step_number, completion_percentage FROM form_submissions
WHERE user_id = $1 AND form_definition_id = $2 AND status = $3
ORDER BY created_at DESC
LIMIT 1
`

type GetFormSubmissionByUserAndFormParams struct {
	UserID           uuid.UUID `json:"user_id"`
	FormDefinitionID uuid.UUID `json:"form_definition_id"`
	Status           string    `json:"status"`
}

func (q *Queries) GetFormSubmissionByUserAndForm(ctx context.Context, arg GetFormSubmissionByUserAndFormParams) (FormSubmission, error) {
	row := q.db.QueryRowContext(ctx, getFormSubmissionByUserAndForm, arg.UserID, arg.FormDefinitionID, arg.Status)
	var i FormSubmission
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.UserID,
		&i.SubmissionData,
		&i.Status,
		&i.ApprovalStatus,
		&i.ApprovalNotes,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStepNumber,
		&i.CompletionPercentage,
	)
	return i, err
}

const getFormSubmissionFiles = `-- name: GetFormSubmissionFiles :many
SELECT id, form_submission_id, field_name, file_name, file_path, file_size, mime_type, bucket, storage_provider, uploaded_at FROM form_submission_files
WHERE form_submission_id = $1
ORDER BY uploaded_at
`

func (q *Queries) GetFormSubmissionFiles(ctx context.Context, formSubmissionID uuid.UUID) ([]FormSubmissionFile, error) {
	rows, err := q.db.QueryContext(ctx, getFormSubmissionFiles, formSubmissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FormSubmissionFile{}
	for rows.Next() {
		var i FormSubmissionFile
		if err := rows.Scan(
			&i.ID,
			&i.FormSubmissionID,
			&i.FieldName,
			&i.FileName,
			&i.FilePath,
			&i.FileSize,
			&i.MimeType,
			&i.Bucket,
			&i.StorageProvider,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersistenceConfig = `-- name: GetPersistenceConfig :one
SELECT id, form_definition_id, persistence_mode, target_configs, field_mappings, transformation_rules, validation_hooks, created_at, updated_at FROM form_persistence_configs
WHERE form_definition_id = $1
`

func (q *Queries) GetPersistenceConfig(ctx context.Context, formDefinitionID uuid.UUID) (FormPersistenceConfig, error) {
	row := q.db.QueryRowContext(ctx, getPersistenceConfig, formDefinitionID)
	var i FormPersistenceConfig
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.PersistenceMode,
		&i.TargetConfigs,
		&i.FieldMappings,
		&i.TransformationRules,
		&i.ValidationHooks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStepProgress = `-- name: GetStepProgress :one
SELECT id, form_submission_id, form_step_id, step_number, status, completed_at, data, created_at, updated_at FROM form_step_progress
WHERE form_submission_id = $1 AND form_step_id = $2
`

type GetStepProgressParams struct {
	FormSubmissionID uuid.NullUUID `json:"form_submission_id"`
	FormStepID       uuid.NullUUID `json:"form_step_id"`
}

func (q *Queries) GetStepProgress(ctx context.Context, arg GetStepProgressParams) (FormStepProgress, error) {
	row := q.db.QueryRowContext(ctx, getStepProgress, arg.FormSubmissionID, arg.FormStepID)
	var i FormStepProgress
	err := row.Scan(
		&i.ID,
		&i.FormSubmissionID,
		&i.FormStepID,
		&i.StepNumber,
		&i.Status,
		&i.CompletedAt,
		&i.Data,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStepProgressBySubmissionAndNumber = `-- name: GetStepProgressBySubmissionAndNumber :one
SELECT id, form_submission_id, form_step_id, step_number, status, completed_at, data, created_at, updated_at FROM form_step_progress
WHERE form_submission_id = $1 AND step_number = $2
`

type GetStepProgressBySubmissionAndNumberParams struct {
	FormSubmissionID uuid.NullUUID `json:"form_submission_id"`
	StepNumber       int32         `json:"step_number"`
}

func (q *Queries) GetStepProgressBySubmissionAndNumber(ctx context.Context, arg GetStepProgressBySubmissionAndNumberParams) (FormStepProgress, error) {
	row := q.db.QueryRowContext(ctx, getStepProgressBySubmissionAndNumber, arg.FormSubmissionID, arg.StepNumber)
	var i FormStepProgress
	err := row.Scan(
		&i.ID,
		&i.FormSubmissionID,
		&i.FormStepID,
		&i.StepNumber,
		&i.Status,
		&i.CompletedAt,
		&i.Data,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFormDefinitions = `-- name: ListFormDefinitions :many
SELECT id, name, slug, description, form_type, version, is_active, is_multi_step, requires_approval, is_editable_after_submission, approval_workflow, created_at, updated_at, created_by FROM form_definitions
WHERE ($1::varchar IS NULL OR form_type = $1)
  AND ($2::boolean IS NULL OR is_active = $2)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListFormDefinitionsParams struct {
	Column1 string `json:"column_1"`
	Column2 bool   `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListFormDefinitions(ctx context.Context, arg ListFormDefinitionsParams) ([]FormDefinition, error) {
	rows, err := q.db.QueryContext(ctx, listFormDefinitions,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FormDefinition{}
	for rows.Next() {
		var i FormDefinition
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.FormType,
			&i.Version,
			&i.IsActive,
			&i.IsMultiStep,
			&i.RequiresApproval,
			&i.IsEditableAfterSubmission,
			&i.ApprovalWorkflow,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFormSubmissions = `-- name: ListFormSubmissions :many
SELECT id, form_definition_id, user_id, submission_data, status, approval_status, approval_notes, approved_by, approved_at, metadata, created_at, updated_at, current_step_number, completion_percentage FROM form_submissions
WHERE ($1::uuid IS NULL OR user_id = $1)
  AND ($2::uuid IS NULL OR form_definition_id = $2)
  AND ($3::varchar IS NULL OR status = $3)
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListFormSubmissionsParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 uuid.UUID `json:"column_2"`
	Column3 string    `json:"column_3"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListFormSubmissions(ctx context.Context, arg ListFormSubmissionsParams) ([]FormSubmission, error) {
	rows, err := q.db.QueryContext(ctx, listFormSubmissions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FormSubmission{}
	for rows.Next() {
		var i FormSubmission
		if err := rows.Scan(
			&i.ID,
			&i.FormDefinitionID,
			&i.UserID,
			&i.SubmissionData,
			&i.Status,
			&i.ApprovalStatus,
			&i.ApprovalNotes,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentStepNumber,
			&i.CompletionPercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFormDefinition = `-- name: UpdateFormDefinition :one
UPDATE form_definitions SET
                            name = $2, description = $3, is_active = $4,
                            approval_workflow = $5, is_editable_after_submission = $6, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, slug, description, form_type, version, is_active, is_multi_step, requires_approval, is_editable_after_submission, approval_workflow, created_at, updated_at, created_by
`

type UpdateFormDefinitionParams struct {
	ID                        uuid.UUID       `json:"id"`
	Name                      string          `json:"name"`
	Description               string          `json:"description"`
	IsActive                  bool            `json:"is_active"`
	ApprovalWorkflow          json.RawMessage `json:"approval_workflow"`
	IsEditableAfterSubmission bool            `json:"is_editable_after_submission"`
}

func (q *Queries) UpdateFormDefinition(ctx context.Context, arg UpdateFormDefinitionParams) (FormDefinition, error) {
	row := q.db.QueryRowContext(ctx, updateFormDefinition,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.IsActive,
		arg.ApprovalWorkflow,
		arg.IsEditableAfterSubmission,
	)
	var i FormDefinition
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.FormType,
		&i.Version,
		&i.IsActive,
		&i.IsMultiStep,
		&i.RequiresApproval,
		&i.IsEditableAfterSubmission,
		&i.ApprovalWorkflow,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const updateFormSubmission = `-- name: UpdateFormSubmission :one
UPDATE form_submissions SET
                            submission_data = $2, status = $3, approval_status = $4,
                            approval_notes = $5, approved_by = $6, approved_at = $7,
                            metadata = $8, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, form_definition_id, user_id, submission_data, status, approval_status, approval_notes, approved_by, approved_at, metadata, created_at, updated_at, current_step_number, completion_percentage
`

type UpdateFormSubmissionParams struct {
	ID             uuid.UUID       `json:"id"`
	SubmissionData json.RawMessage `json:"submission_data"`
	Status         string          `json:"status"`
	ApprovalStatus string          `json:"approval_status"`
	ApprovalNotes  string          `json:"approval_notes"`
	ApprovedBy     uuid.NullUUID   `json:"approved_by"`
	ApprovedAt     time.Time       `json:"approved_at"`
	Metadata       json.RawMessage `json:"metadata"`
}

func (q *Queries) UpdateFormSubmission(ctx context.Context, arg UpdateFormSubmissionParams) (FormSubmission, error) {
	row := q.db.QueryRowContext(ctx, updateFormSubmission,
		arg.ID,
		arg.SubmissionData,
		arg.Status,
		arg.ApprovalStatus,
		arg.ApprovalNotes,
		arg.ApprovedBy,
		arg.ApprovedAt,
		arg.Metadata,
	)
	var i FormSubmission
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.UserID,
		&i.SubmissionData,
		&i.Status,
		&i.ApprovalStatus,
		&i.ApprovalNotes,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStepNumber,
		&i.CompletionPercentage,
	)
	return i, err
}

const updatePersistenceConfig = `-- name: UpdatePersistenceConfig :one
UPDATE form_persistence_configs SET
                                    persistence_mode = $2, target_configs = $3, field_mappings = $4,
                                    transformation_rules = $5, validation_hooks = $6,
                                    updated_at = CURRENT_TIMESTAMP
WHERE form_definition_id = $1
RETURNING id, form_definition_id, persistence_mode, target_configs, field_mappings, transformation_rules, validation_hooks, created_at, updated_at
`

type UpdatePersistenceConfigParams struct {
	FormDefinitionID    uuid.UUID       `json:"form_definition_id"`
	PersistenceMode     string          `json:"persistence_mode"`
	TargetConfigs       json.RawMessage `json:"target_configs"`
	FieldMappings       json.RawMessage `json:"field_mappings"`
	TransformationRules json.RawMessage `json:"transformation_rules"`
	ValidationHooks     json.RawMessage `json:"validation_hooks"`
}

func (q *Queries) UpdatePersistenceConfig(ctx context.Context, arg UpdatePersistenceConfigParams) (FormPersistenceConfig, error) {
	row := q.db.QueryRowContext(ctx, updatePersistenceConfig,
		arg.FormDefinitionID,
		arg.PersistenceMode,
		arg.TargetConfigs,
		arg.FieldMappings,
		arg.TransformationRules,
		arg.ValidationHooks,
	)
	var i FormPersistenceConfig
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.PersistenceMode,
		&i.TargetConfigs,
		&i.FieldMappings,
		&i.TransformationRules,
		&i.ValidationHooks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStepProgress = `-- name: UpdateStepProgress :one
UPDATE form_step_progress SET
                              status = $2,
                              data = $3,
                              completed_at = CASE WHEN $2 = 'completed' THEN CURRENT_TIMESTAMP ELSE completed_at END,
                              updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, form_submission_id, form_step_id, step_number, status, completed_at, data, created_at, updated_at
`

type UpdateStepProgressParams struct {
	ID     uuid.UUID             `json:"id"`
	Status sql.NullString        `json:"status"`
	Data   pqtype.NullRawMessage `json:"data"`
}

func (q *Queries) UpdateStepProgress(ctx context.Context, arg UpdateStepProgressParams) (FormStepProgress, error) {
	row := q.db.QueryRowContext(ctx, updateStepProgress, arg.ID, arg.Status, arg.Data)
	var i FormStepProgress
	err := row.Scan(
		&i.ID,
		&i.FormSubmissionID,
		&i.FormStepID,
		&i.StepNumber,
		&i.Status,
		&i.CompletedAt,
		&i.Data,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubmissionProgress = `-- name: UpdateSubmissionProgress :one
UPDATE form_submissions SET
                            current_step_number = $2,
                            completion_percentage = $3,
                            updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, form_definition_id, user_id, submission_data, status, approval_status, approval_notes, approved_by, approved_at, metadata, created_at, updated_at, current_step_number, completion_percentage
`

type UpdateSubmissionProgressParams struct {
	ID                   uuid.UUID     `json:"id"`
	CurrentStepNumber    sql.NullInt32 `json:"current_step_number"`
	CompletionPercentage sql.NullInt32 `json:"completion_percentage"`
}

func (q *Queries) UpdateSubmissionProgress(ctx context.Context, arg UpdateSubmissionProgressParams) (FormSubmission, error) {
	row := q.db.QueryRowContext(ctx, updateSubmissionProgress, arg.ID, arg.CurrentStepNumber, arg.CompletionPercentage)
	var i FormSubmission
	err := row.Scan(
		&i.ID,
		&i.FormDefinitionID,
		&i.UserID,
		&i.SubmissionData,
		&i.Status,
		&i.ApprovalStatus,
		&i.ApprovalNotes,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStepNumber,
		&i.CompletionPercentage,
	)
	return i, err
}
