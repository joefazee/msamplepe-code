// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const activateUser = `-- name: ActivateUser :one
UPDATE users SET active = true, suspended_at = null WHERE id = $1 RETURNING id, email, country_code, phone, password, created_at, updated_at, password_changed_at, active, suspended_at, account_type, first_name, middle_name, last_name, business_name, address, account_number, bank_name, bank_code, bvn, city, state, zipcode, kyc_verified, kyc_verified_at, version
`

func (q *Queries) ActivateUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, activateUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CountryCode,
		&i.Phone,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordChangedAt,
		&i.Active,
		&i.SuspendedAt,
		&i.AccountType,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.BusinessName,
		&i.Address,
		&i.AccountNumber,
		&i.BankName,
		&i.BankCode,
		&i.Bvn,
		&i.City,
		&i.State,
		&i.Zipcode,
		&i.KycVerified,
		&i.KycVerifiedAt,
		&i.Version,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email,
    country_code,
    phone,
    password,
    first_name,
    middle_name,
    last_name,
    account_type,
    business_name
) VALUES (
     $1,
     $2,
     $3,
     $4,
     $5,
     $6,
     $7,
     $8,
     $9
) RETURNING id, email, country_code, phone, password, created_at, updated_at, password_changed_at, active, suspended_at, account_type, first_name, middle_name, last_name, business_name, address, account_number, bank_name, bank_code, bvn, city, state, zipcode, kyc_verified, kyc_verified_at, version
`

type CreateUserParams struct {
	Email        string `json:"email"`
	CountryCode  string `json:"country_code"`
	Phone        string `json:"phone"`
	Password     string `json:"password"`
	FirstName    string `json:"first_name"`
	MiddleName   string `json:"middle_name"`
	LastName     string `json:"last_name"`
	AccountType  string `json:"account_type"`
	BusinessName string `json:"business_name"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Email,
		arg.CountryCode,
		arg.Phone,
		arg.Password,
		arg.FirstName,
		arg.MiddleName,
		arg.LastName,
		arg.AccountType,
		arg.BusinessName,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CountryCode,
		&i.Phone,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordChangedAt,
		&i.Active,
		&i.SuspendedAt,
		&i.AccountType,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.BusinessName,
		&i.Address,
		&i.AccountNumber,
		&i.BankName,
		&i.BankCode,
		&i.Bvn,
		&i.City,
		&i.State,
		&i.Zipcode,
		&i.KycVerified,
		&i.KycVerifiedAt,
		&i.Version,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :one
UPDATE users SET active = false, suspended_at = NOW()::timestamp WHERE id = $1 RETURNING id, email, country_code, phone, password, created_at, updated_at, password_changed_at, active, suspended_at, account_type, first_name, middle_name, last_name, business_name, address, account_number, bank_name, bank_code, bvn, city, state, zipcode, kyc_verified, kyc_verified_at, version
`

func (q *Queries) DeactivateUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, deactivateUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CountryCode,
		&i.Phone,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordChangedAt,
		&i.Active,
		&i.SuspendedAt,
		&i.AccountType,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.BusinessName,
		&i.Address,
		&i.AccountNumber,
		&i.BankName,
		&i.BankCode,
		&i.Bvn,
		&i.City,
		&i.State,
		&i.Zipcode,
		&i.KycVerified,
		&i.KycVerifiedAt,
		&i.Version,
	)
	return i, err
}

const getOtherUserByEmail = `-- name: GetOtherUserByEmail :one
SELECT id, email, country_code, phone, password, created_at, updated_at, password_changed_at, active, suspended_at, account_type, first_name, middle_name, last_name, business_name, address, account_number, bank_name, bank_code, bvn, city, state, zipcode, kyc_verified, kyc_verified_at, version FROM users WHERE LOWER(email) = $1 AND id != $2 LIMIT  1
`

type GetOtherUserByEmailParams struct {
	Email string    `json:"email"`
	ID    uuid.UUID `json:"id"`
}

func (q *Queries) GetOtherUserByEmail(ctx context.Context, arg GetOtherUserByEmailParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getOtherUserByEmail, arg.Email, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CountryCode,
		&i.Phone,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordChangedAt,
		&i.Active,
		&i.SuspendedAt,
		&i.AccountType,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.BusinessName,
		&i.Address,
		&i.AccountNumber,
		&i.BankName,
		&i.BankCode,
		&i.Bvn,
		&i.City,
		&i.State,
		&i.Zipcode,
		&i.KycVerified,
		&i.KycVerifiedAt,
		&i.Version,
	)
	return i, err
}

const getOtherUserByPhone = `-- name: GetOtherUserByPhone :one
SELECT id, email, country_code, phone, password, created_at, updated_at, password_changed_at, active, suspended_at, account_type, first_name, middle_name, last_name, business_name, address, account_number, bank_name, bank_code, bvn, city, state, zipcode, kyc_verified, kyc_verified_at, version FROM users WHERE phone = $1 AND id != $2 LIMIT  1
`

type GetOtherUserByPhoneParams struct {
	Phone string    `json:"phone"`
	ID    uuid.UUID `json:"id"`
}

func (q *Queries) GetOtherUserByPhone(ctx context.Context, arg GetOtherUserByPhoneParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getOtherUserByPhone, arg.Phone, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CountryCode,
		&i.Phone,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordChangedAt,
		&i.Active,
		&i.SuspendedAt,
		&i.AccountType,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.BusinessName,
		&i.Address,
		&i.AccountNumber,
		&i.BankName,
		&i.BankCode,
		&i.Bvn,
		&i.City,
		&i.State,
		&i.Zipcode,
		&i.KycVerified,
		&i.KycVerifiedAt,
		&i.Version,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, country_code, phone, password, created_at, updated_at, password_changed_at, active, suspended_at, account_type, first_name, middle_name, last_name, business_name, address, account_number, bank_name, bank_code, bvn, city, state, zipcode, kyc_verified, kyc_verified_at, version FROM users WHERE id = $1 LIMIT  1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CountryCode,
		&i.Phone,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordChangedAt,
		&i.Active,
		&i.SuspendedAt,
		&i.AccountType,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.BusinessName,
		&i.Address,
		&i.AccountNumber,
		&i.BankName,
		&i.BankCode,
		&i.Bvn,
		&i.City,
		&i.State,
		&i.Zipcode,
		&i.KycVerified,
		&i.KycVerifiedAt,
		&i.Version,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, country_code, phone, password, created_at, updated_at, password_changed_at, active, suspended_at, account_type, first_name, middle_name, last_name, business_name, address, account_number, bank_name, bank_code, bvn, city, state, zipcode, kyc_verified, kyc_verified_at, version FROM users WHERE LOWER(email) = $1 LIMIT  1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CountryCode,
		&i.Phone,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordChangedAt,
		&i.Active,
		&i.SuspendedAt,
		&i.AccountType,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.BusinessName,
		&i.Address,
		&i.AccountNumber,
		&i.BankName,
		&i.BankCode,
		&i.Bvn,
		&i.City,
		&i.State,
		&i.Zipcode,
		&i.KycVerified,
		&i.KycVerifiedAt,
		&i.Version,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, email, country_code, phone, password, created_at, updated_at, password_changed_at, active, suspended_at, account_type, first_name, middle_name, last_name, business_name, address, account_number, bank_name, bank_code, bvn, city, state, zipcode, kyc_verified, kyc_verified_at, version FROM users WHERE phone = $1 LIMIT  1
`

func (q *Queries) GetUserByPhone(ctx context.Context, phone string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByPhone, phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CountryCode,
		&i.Phone,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordChangedAt,
		&i.Active,
		&i.SuspendedAt,
		&i.AccountType,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.BusinessName,
		&i.Address,
		&i.AccountNumber,
		&i.BankName,
		&i.BankCode,
		&i.Bvn,
		&i.City,
		&i.State,
		&i.Zipcode,
		&i.KycVerified,
		&i.KycVerifiedAt,
		&i.Version,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET account_type = COALESCE($1, account_type),
    phone = COALESCE($2, phone),
    country_code = COALESCE($3, country_code),
    email = COALESCE($4, email),
    active = COALESCE($5, active),
    password = COALESCE($6, password),
    first_name = COALESCE($7, first_name),
    middle_name = COALESCE($8, middle_name),
    last_name = COALESCE($9, last_name),
    business_name = COALESCE($10, business_name),
    address = COALESCE($11, address),
    city = COALESCE($12, city),
    state = COALESCE($13, state),
    zipcode = COALESCE($14, zipcode),
    account_number = COALESCE($15, account_number),
    bvn = COALESCE($16, bvn),
    bank_name = COALESCE($17, bank_name),
    bank_code = COALESCE($18, bank_code),
    kyc_verified = COALESCE($19, kyc_verified),
    kyc_verified_at = COALESCE($20, kyc_verified_at),
    version = version + 1
WHERE id = $21 RETURNING id, email, country_code, phone, password, created_at, updated_at, password_changed_at, active, suspended_at, account_type, first_name, middle_name, last_name, business_name, address, account_number, bank_name, bank_code, bvn, city, state, zipcode, kyc_verified, kyc_verified_at, version
`

type UpdateUserParams struct {
	AccountType   sql.NullString `json:"account_type"`
	Phone         sql.NullString `json:"phone"`
	CountryCode   sql.NullString `json:"country_code"`
	Email         sql.NullString `json:"email"`
	Active        sql.NullBool   `json:"active"`
	Password      sql.NullString `json:"password"`
	FirstName     sql.NullString `json:"first_name"`
	MiddleName    sql.NullString `json:"middle_name"`
	LastName      sql.NullString `json:"last_name"`
	BusinessName  sql.NullString `json:"business_name"`
	Address       sql.NullString `json:"address"`
	City          sql.NullString `json:"city"`
	State         sql.NullString `json:"state"`
	Zipcode       sql.NullString `json:"zipcode"`
	AccountNumber sql.NullString `json:"account_number"`
	Bvn           sql.NullString `json:"bvn"`
	BankName      sql.NullString `json:"bank_name"`
	BankCode      sql.NullString `json:"bank_code"`
	KycVerified   sql.NullString `json:"kyc_verified"`
	KycVerifiedAt sql.NullTime   `json:"kyc_verified_at"`
	ID            uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.AccountType,
		arg.Phone,
		arg.CountryCode,
		arg.Email,
		arg.Active,
		arg.Password,
		arg.FirstName,
		arg.MiddleName,
		arg.LastName,
		arg.BusinessName,
		arg.Address,
		arg.City,
		arg.State,
		arg.Zipcode,
		arg.AccountNumber,
		arg.Bvn,
		arg.BankName,
		arg.BankCode,
		arg.KycVerified,
		arg.KycVerifiedAt,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CountryCode,
		&i.Phone,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PasswordChangedAt,
		&i.Active,
		&i.SuspendedAt,
		&i.AccountType,
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.BusinessName,
		&i.Address,
		&i.AccountNumber,
		&i.BankName,
		&i.BankCode,
		&i.Bvn,
		&i.City,
		&i.State,
		&i.Zipcode,
		&i.KycVerified,
		&i.KycVerifiedAt,
		&i.Version,
	)
	return i, err
}

const updateUserKYCApproval = `-- name: UpdateUserKYCApproval :exec
UPDATE users SET kyc_verified = $1, kyc_verified_at = NOW()::timestamp WHERE id = $2
`

type UpdateUserKYCApprovalParams struct {
	KycVerified string    `json:"kyc_verified"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserKYCApproval(ctx context.Context, arg UpdateUserKYCApprovalParams) error {
	_, err := q.db.ExecContext(ctx, updateUserKYCApproval, arg.KycVerified, arg.ID)
	return err
}
