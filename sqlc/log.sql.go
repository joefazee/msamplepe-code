// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: log.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createLog = `-- name: CreateLog :one
INSERT INTO logs (log_data) VALUES ($1) RETURNING id, log_data, created_at
`

func (q *Queries) CreateLog(ctx context.Context, logData json.RawMessage) (Log, error) {
	row := q.db.QueryRowContext(ctx, createLog, logData)
	var i Log
	err := row.Scan(&i.ID, &i.LogData, &i.CreatedAt)
	return i, err
}

const deleteLogsOlderThanNDays = `-- name: DeleteLogsOlderThanNDays :exec
DELETE FROM logs WHERE created_at < NOW() - INTERVAL '1 day' * $1
`

func (q *Queries) DeleteLogsOlderThanNDays(ctx context.Context, dollar_1 interface{}) error {
	_, err := q.db.ExecContext(ctx, deleteLogsOlderThanNDays, dollar_1)
	return err
}

const getLogs = `-- name: GetLogs :many
SELECT id, log_data, created_at FROM logs ORDER BY created_at DESC LIMIT $1
`

func (q *Queries) GetLogs(ctx context.Context, limit int32) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, getLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(&i.ID, &i.LogData, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByJSONContent = `-- name: GetLogsByJSONContent :many
SELECT id, log_data, created_at FROM logs WHERE log_data @> $1::jsonb ORDER BY created_at DESC LIMIT $2
`

type GetLogsByJSONContentParams struct {
	Column1 json.RawMessage `json:"column_1"`
	Limit   int32           `json:"limit"`
}

func (q *Queries) GetLogsByJSONContent(ctx context.Context, arg GetLogsByJSONContentParams) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, getLogsByJSONContent, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(&i.ID, &i.LogData, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByMessage = `-- name: GetLogsByMessage :many
SELECT id, log_data, created_at FROM logs WHERE log_data->>'message' = $1 ORDER BY created_at DESC LIMIT $2
`

type GetLogsByMessageParams struct {
	LogData json.RawMessage `json:"log_data"`
	Limit   int32           `json:"limit"`
}

func (q *Queries) GetLogsByMessage(ctx context.Context, arg GetLogsByMessageParams) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, getLogsByMessage, arg.LogData, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(&i.ID, &i.LogData, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLogsByMessageLike = `-- name: SearchLogsByMessageLike :many
SELECT id, log_data, created_at FROM logs WHERE log_data->>'message' LIKE '%' || $1 || '%' ORDER BY created_at DESC LIMIT $2
`

type SearchLogsByMessageLikeParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
}

func (q *Queries) SearchLogsByMessageLike(ctx context.Context, arg SearchLogsByMessageLikeParams) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, searchLogsByMessageLike, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(&i.ID, &i.LogData, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
