// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: transaction_history.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createTransactionHistory = `-- name: CreateTransactionHistory :exec
INSERT INTO transaction_history (
    transaction_id,
    user_id,
    amount,
    payload,
    old_status,
    new_status,
    reason
) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, transaction_id, user_id, amount, payload, old_status, new_status, reason, created_at
`

type CreateTransactionHistoryParams struct {
	TransactionID uuid.UUID       `json:"transaction_id"`
	UserID        uuid.UUID       `json:"user_id"`
	Amount        decimal.Decimal `json:"amount"`
	Payload       json.RawMessage `json:"payload"`
	OldStatus     string          `json:"old_status"`
	NewStatus     string          `json:"new_status"`
	Reason        string          `json:"reason"`
}

func (q *Queries) CreateTransactionHistory(ctx context.Context, arg CreateTransactionHistoryParams) error {
	_, err := q.db.ExecContext(ctx, createTransactionHistory,
		arg.TransactionID,
		arg.UserID,
		arg.Amount,
		arg.Payload,
		arg.OldStatus,
		arg.NewStatus,
		arg.Reason,
	)
	return err
}

const getTransactionHistories = `-- name: GetTransactionHistories :many
SELECT id, transaction_id, user_id, amount, payload, old_status, new_status, reason, created_at FROM transaction_history
         WHERE transaction_id = $1
         ORDER BY created_at DESC
         LIMIT $2 OFFSET $3
`

type GetTransactionHistoriesParams struct {
	TransactionID uuid.UUID `json:"transaction_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
}

func (q *Queries) GetTransactionHistories(ctx context.Context, arg GetTransactionHistoriesParams) ([]TransactionHistory, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionHistories, arg.TransactionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TransactionHistory{}
	for rows.Next() {
		var i TransactionHistory
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.UserID,
			&i.Amount,
			&i.Payload,
			&i.OldStatus,
			&i.NewStatus,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
