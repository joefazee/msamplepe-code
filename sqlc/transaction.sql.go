// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transaction.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/shopspring/decimal"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
           user_id,
           wallet_id,
           amount,
           type,
           source,
           status,
           action,
           tag,
           payment_method,
           currency_id,
           fees_amount,
           fees_is_percentage,
           rate,
           payload,
           requires_settlement,
           settlement_status,
           is_invoice_uploaded
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17) RETURNING id, user_id, wallet_id, amount, type, source, action, status, tag, currency_id, payment_method, fees_amount, rate, fees_is_percentage, payload, created_at, updated_at, requires_settlement, settlement_status, is_invoice_uploaded, tracking_number, gateway, company_name
`

type CreateTransactionParams struct {
	UserID             uuid.UUID       `json:"user_id"`
	WalletID           uuid.UUID       `json:"wallet_id"`
	Amount             decimal.Decimal `json:"amount"`
	Type               string          `json:"type"`
	Source             string          `json:"source"`
	Status             string          `json:"status"`
	Action             string          `json:"action"`
	Tag                string          `json:"tag"`
	PaymentMethod      string          `json:"payment_method"`
	CurrencyID         int32           `json:"currency_id"`
	FeesAmount         decimal.Decimal `json:"fees_amount"`
	FeesIsPercentage   bool            `json:"fees_is_percentage"`
	Rate               decimal.Decimal `json:"rate"`
	Payload            json.RawMessage `json:"payload"`
	RequiresSettlement bool            `json:"requires_settlement"`
	SettlementStatus   string          `json:"settlement_status"`
	IsInvoiceUploaded  bool            `json:"is_invoice_uploaded"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.UserID,
		arg.WalletID,
		arg.Amount,
		arg.Type,
		arg.Source,
		arg.Status,
		arg.Action,
		arg.Tag,
		arg.PaymentMethod,
		arg.CurrencyID,
		arg.FeesAmount,
		arg.FeesIsPercentage,
		arg.Rate,
		arg.Payload,
		arg.RequiresSettlement,
		arg.SettlementStatus,
		arg.IsInvoiceUploaded,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Amount,
		&i.Type,
		&i.Source,
		&i.Action,
		&i.Status,
		&i.Tag,
		&i.CurrencyID,
		&i.PaymentMethod,
		&i.FeesAmount,
		&i.Rate,
		&i.FeesIsPercentage,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequiresSettlement,
		&i.SettlementStatus,
		&i.IsInvoiceUploaded,
		&i.TrackingNumber,
		&i.Gateway,
		&i.CompanyName,
	)
	return i, err
}

const getDailySwap = `-- name: GetDailySwap :many
SELECT id, user_id, wallet_id, amount, type, source, action, status, tag, currency_id, payment_method, fees_amount, rate, fees_is_percentage, payload, created_at, updated_at, requires_settlement, settlement_status, is_invoice_uploaded, tracking_number, gateway, company_name FROM transactions WHERE action = 'swap' AND status = $1 AND created_at >= $2 AND created_at < $2 + INTERVAL '1 day'
`

type GetDailySwapParams struct {
	Status    string    `json:"status"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) GetDailySwap(ctx context.Context, arg GetDailySwapParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getDailySwap, arg.Status, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletID,
			&i.Amount,
			&i.Type,
			&i.Source,
			&i.Action,
			&i.Status,
			&i.Tag,
			&i.CurrencyID,
			&i.PaymentMethod,
			&i.FeesAmount,
			&i.Rate,
			&i.FeesIsPercentage,
			&i.Payload,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RequiresSettlement,
			&i.SettlementStatus,
			&i.IsInvoiceUploaded,
			&i.TrackingNumber,
			&i.Gateway,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, user_id, wallet_id, amount, type, source, action, status, tag, currency_id, payment_method, fees_amount, rate, fees_is_percentage, payload, created_at, updated_at, requires_settlement, settlement_status, is_invoice_uploaded, tracking_number, gateway, company_name FROM transactions WHERE id = $1
`

func (q *Queries) GetTransaction(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Amount,
		&i.Type,
		&i.Source,
		&i.Action,
		&i.Status,
		&i.Tag,
		&i.CurrencyID,
		&i.PaymentMethod,
		&i.FeesAmount,
		&i.Rate,
		&i.FeesIsPercentage,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequiresSettlement,
		&i.SettlementStatus,
		&i.IsInvoiceUploaded,
		&i.TrackingNumber,
		&i.Gateway,
		&i.CompanyName,
	)
	return i, err
}

const getTransactionBySchemeAndID = `-- name: GetTransactionBySchemeAndID :one
SELECT
    id, user_id, wallet_id, amount, type, source, action, status, tag, currency_id, payment_method, fees_amount, rate, fees_is_percentage, payload, created_at, updated_at, requires_settlement, settlement_status, is_invoice_uploaded, tracking_number, gateway, company_name
FROM
    transactions
WHERE
    id = $1 AND
    payload->'recipient'->>'scheme' = $2
`

type GetTransactionBySchemeAndIDParams struct {
	ID      uuid.UUID       `json:"id"`
	Payload json.RawMessage `json:"payload"`
}

func (q *Queries) GetTransactionBySchemeAndID(ctx context.Context, arg GetTransactionBySchemeAndIDParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionBySchemeAndID, arg.ID, arg.Payload)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Amount,
		&i.Type,
		&i.Source,
		&i.Action,
		&i.Status,
		&i.Tag,
		&i.CurrencyID,
		&i.PaymentMethod,
		&i.FeesAmount,
		&i.Rate,
		&i.FeesIsPercentage,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequiresSettlement,
		&i.SettlementStatus,
		&i.IsInvoiceUploaded,
		&i.TrackingNumber,
		&i.Gateway,
		&i.CompanyName,
	)
	return i, err
}

const getTransactionSchemeByID = `-- name: GetTransactionSchemeByID :one
SELECT
    payload->'recipient'->>'scheme' AS scheme
FROM
    transactions
WHERE
    id = $1 AND action = 'ext-transfer'
`

func (q *Queries) GetTransactionSchemeByID(ctx context.Context, id uuid.UUID) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTransactionSchemeByID, id)
	var scheme interface{}
	err := row.Scan(&scheme)
	return scheme, err
}

const getUserTransactionByManyStatus = `-- name: GetUserTransactionByManyStatus :one
SELECT id, user_id, wallet_id, amount, type, source, action, status, tag, currency_id, payment_method, fees_amount, rate, fees_is_percentage, payload, created_at, updated_at, requires_settlement, settlement_status, is_invoice_uploaded, tracking_number, gateway, company_name FROM transactions WHERE id  = $1 AND user_id = $2 AND status = ANY($3::varchar[])
`

type GetUserTransactionByManyStatusParams struct {
	ID      uuid.UUID `json:"id"`
	UserID  uuid.UUID `json:"user_id"`
	Column3 []string  `json:"column_3"`
}

func (q *Queries) GetUserTransactionByManyStatus(ctx context.Context, arg GetUserTransactionByManyStatusParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getUserTransactionByManyStatus, arg.ID, arg.UserID, pq.Array(arg.Column3))
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Amount,
		&i.Type,
		&i.Source,
		&i.Action,
		&i.Status,
		&i.Tag,
		&i.CurrencyID,
		&i.PaymentMethod,
		&i.FeesAmount,
		&i.Rate,
		&i.FeesIsPercentage,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequiresSettlement,
		&i.SettlementStatus,
		&i.IsInvoiceUploaded,
		&i.TrackingNumber,
		&i.Gateway,
		&i.CompanyName,
	)
	return i, err
}

const getUserTransactionByStatus = `-- name: GetUserTransactionByStatus :one
SELECT id, user_id, wallet_id, amount, type, source, action, status, tag, currency_id, payment_method, fees_amount, rate, fees_is_percentage, payload, created_at, updated_at, requires_settlement, settlement_status, is_invoice_uploaded, tracking_number, gateway, company_name FROM transactions WHERE id  = $1 AND user_id = $2 AND status = $3
`

type GetUserTransactionByStatusParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
	Status string    `json:"status"`
}

func (q *Queries) GetUserTransactionByStatus(ctx context.Context, arg GetUserTransactionByStatusParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getUserTransactionByStatus, arg.ID, arg.UserID, arg.Status)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Amount,
		&i.Type,
		&i.Source,
		&i.Action,
		&i.Status,
		&i.Tag,
		&i.CurrencyID,
		&i.PaymentMethod,
		&i.FeesAmount,
		&i.Rate,
		&i.FeesIsPercentage,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequiresSettlement,
		&i.SettlementStatus,
		&i.IsInvoiceUploaded,
		&i.TrackingNumber,
		&i.Gateway,
		&i.CompanyName,
	)
	return i, err
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions
SET status = COALESCE($1, status),
    tag = COALESCE($2, tag),
    requires_settlement = COALESCE($3, requires_settlement),
    settlement_status = COALESCE($4, settlement_status),
    gateway = COALESCE($5, gateway),
    tracking_number = COALESCE($6, tracking_number),
    company_name = COALESCE($7, company_name),
    updated_at = NOW()
WHERE id = $8 RETURNING id, user_id, wallet_id, amount, type, source, action, status, tag, currency_id, payment_method, fees_amount, rate, fees_is_percentage, payload, created_at, updated_at, requires_settlement, settlement_status, is_invoice_uploaded, tracking_number, gateway, company_name
`

type UpdateTransactionParams struct {
	Status             string    `json:"status"`
	Tag                string    `json:"tag"`
	RequiresSettlement bool      `json:"requires_settlement"`
	SettlementStatus   string    `json:"settlement_status"`
	Gateway            string    `json:"gateway"`
	TrackingNumber     string    `json:"tracking_number"`
	CompanyName        string    `json:"company_name"`
	ID                 uuid.UUID `json:"id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, updateTransaction,
		arg.Status,
		arg.Tag,
		arg.RequiresSettlement,
		arg.SettlementStatus,
		arg.Gateway,
		arg.TrackingNumber,
		arg.CompanyName,
		arg.ID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Amount,
		&i.Type,
		&i.Source,
		&i.Action,
		&i.Status,
		&i.Tag,
		&i.CurrencyID,
		&i.PaymentMethod,
		&i.FeesAmount,
		&i.Rate,
		&i.FeesIsPercentage,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequiresSettlement,
		&i.SettlementStatus,
		&i.IsInvoiceUploaded,
		&i.TrackingNumber,
		&i.Gateway,
		&i.CompanyName,
	)
	return i, err
}

const updateTransactionInvoiceStatus = `-- name: UpdateTransactionInvoiceStatus :one
UPDATE transactions SET is_invoice_uploaded = true WHERE id = $1 RETURNING id, user_id, wallet_id, amount, type, source, action, status, tag, currency_id, payment_method, fees_amount, rate, fees_is_percentage, payload, created_at, updated_at, requires_settlement, settlement_status, is_invoice_uploaded, tracking_number, gateway, company_name
`

func (q *Queries) UpdateTransactionInvoiceStatus(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, updateTransactionInvoiceStatus, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Amount,
		&i.Type,
		&i.Source,
		&i.Action,
		&i.Status,
		&i.Tag,
		&i.CurrencyID,
		&i.PaymentMethod,
		&i.FeesAmount,
		&i.Rate,
		&i.FeesIsPercentage,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequiresSettlement,
		&i.SettlementStatus,
		&i.IsInvoiceUploaded,
		&i.TrackingNumber,
		&i.Gateway,
		&i.CompanyName,
	)
	return i, err
}

const updateTransactionInvoiceUploadStatus = `-- name: UpdateTransactionInvoiceUploadStatus :one
UPDATE transactions SET is_invoice_uploaded = $1 WHERE id = $2 RETURNING id, user_id, wallet_id, amount, type, source, action, status, tag, currency_id, payment_method, fees_amount, rate, fees_is_percentage, payload, created_at, updated_at, requires_settlement, settlement_status, is_invoice_uploaded, tracking_number, gateway, company_name
`

type UpdateTransactionInvoiceUploadStatusParams struct {
	IsInvoiceUploaded bool      `json:"is_invoice_uploaded"`
	ID                uuid.UUID `json:"id"`
}

func (q *Queries) UpdateTransactionInvoiceUploadStatus(ctx context.Context, arg UpdateTransactionInvoiceUploadStatusParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, updateTransactionInvoiceUploadStatus, arg.IsInvoiceUploaded, arg.ID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.Amount,
		&i.Type,
		&i.Source,
		&i.Action,
		&i.Status,
		&i.Tag,
		&i.CurrencyID,
		&i.PaymentMethod,
		&i.FeesAmount,
		&i.Rate,
		&i.FeesIsPercentage,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequiresSettlement,
		&i.SettlementStatus,
		&i.IsInvoiceUploaded,
		&i.TrackingNumber,
		&i.Gateway,
		&i.CompanyName,
	)
	return i, err
}
