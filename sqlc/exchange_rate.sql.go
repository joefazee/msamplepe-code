// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: exchange_rate.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const calculateExchangeRate = `-- name: CalculateExchangeRate :one
SELECT CAST(
               COALESCE(
                           account_level_rates.rate - COALESCE(agent_daily_discounts.calculated_discount_amount, 0),
                           exchange_rates.rate - COALESCE(agent_daily_discounts.calculated_discount_amount, 0)
                   ) AS numeric
           )                                 AS rate,
       COALESCE(account_level_rates.rate, 0) as account_level_rate,
       COALESCE(exchange_rates.rate, 0)      as exchange_rate,
       COALESCE(account_level_rates.version, exchange_rates.version) as exchange_rate_version,
       COALESCE(account_level_rates.spread, exchange_rates.spread) as spread,
       exchange_rates.valid_from             as exchange_rate_valid_from,
       exchange_rates.valid_until            as exchange_rate_valid_until,
       account_level_rates.valid_from        as account_level_valid_from,
       account_level_rates.valid_until       as account_level_valid_until,
       COALESCE(exchange_rates.id, 0)        as exchange_rate_id,
       COALESCE(account_level_rates.id, 0)        as account_level_rate_id,
       CAST(
               COALESCE(
                       agent_daily_discounts.calculated_discount_amount,
                       0
                   ) AS numeric
           )  AS calculated_discount_amount,
       CAST((account_level_rates.rate IS NULL) AS boolean) AS is_based_rate,
       CAST((agent_daily_discounts.calculated_discount_amount IS NOT NULL) AS boolean) AS has_discount

FROM (SELECT ex.id, ex.rate, ex.spread, ex.valid_from, ex.valid_until, ex.version
      FROM exchange_rates as ex
      WHERE ex.base_currency_id = $1
        AND ex.quote_currency_id = $2
        AND ex.type = $4
        AND ex.valid_from <= now()
        AND (ex.valid_until IS NULL OR ex.valid_until > now())
      ORDER BY ex.valid_from DESC
      LIMIT 1) AS exchange_rates
         FULL OUTER JOIN
     (SELECT id, rate, spread, valid_from, valid_until, version
      FROM account_level_rates as aex
      WHERE  aex.user_id = $3
        AND aex.base_currency_id = $1
        AND aex.quote_currency_id = $2
        AND aex.type = $4
        AND aex.valid_from <= now()
        AND (aex.valid_until IS NULL OR aex.valid_until > now())
      ORDER BY valid_from DESC
      LIMIT 1) AS account_level_rates ON TRUE
         LEFT JOIN LATERAL
    (SELECT add.discount_amount,
            add.discount_multiple,
            add.top_up_amount,
            add.start_timestamp,
            (add.discount_amount * floor(add.top_up_amount / add.discount_multiple) ) as calculated_discount_amount
     FROM agent_daily_discounts as add
     WHERE add.user_id = $3
       AND add.base_currency_id = $1
       AND add.start_timestamp <= now()
       AND add.end_timestamp > now()
     ORDER BY add.start_timestamp DESC
     LIMIT 1) AS agent_daily_discounts ON TRUE
`

type CalculateExchangeRateParams struct {
	BaseCurrencyID  int32     `json:"base_currency_id"`
	QuoteCurrencyID int32     `json:"quote_currency_id"`
	UserID          uuid.UUID `json:"user_id"`
	Type            string    `json:"type"`
}

type CalculateExchangeRateRow struct {
	Rate                     decimal.Decimal `json:"rate"`
	AccountLevelRate         decimal.Decimal `json:"account_level_rate"`
	ExchangeRate             decimal.Decimal `json:"exchange_rate"`
	ExchangeRateVersion      time.Time       `json:"exchange_rate_version"`
	Spread                   decimal.Decimal `json:"spread"`
	ExchangeRateValidFrom    sql.NullTime    `json:"exchange_rate_valid_from"`
	ExchangeRateValidUntil   sql.NullTime    `json:"exchange_rate_valid_until"`
	AccountLevelValidFrom    sql.NullTime    `json:"account_level_valid_from"`
	AccountLevelValidUntil   sql.NullTime    `json:"account_level_valid_until"`
	ExchangeRateID           int32           `json:"exchange_rate_id"`
	AccountLevelRateID       int32           `json:"account_level_rate_id"`
	CalculatedDiscountAmount decimal.Decimal `json:"calculated_discount_amount"`
	IsBasedRate              bool            `json:"is_based_rate"`
	HasDiscount              bool            `json:"has_discount"`
}

func (q *Queries) CalculateExchangeRate(ctx context.Context, arg CalculateExchangeRateParams) (CalculateExchangeRateRow, error) {
	row := q.db.QueryRowContext(ctx, calculateExchangeRate,
		arg.BaseCurrencyID,
		arg.QuoteCurrencyID,
		arg.UserID,
		arg.Type,
	)
	var i CalculateExchangeRateRow
	err := row.Scan(
		&i.Rate,
		&i.AccountLevelRate,
		&i.ExchangeRate,
		&i.ExchangeRateVersion,
		&i.Spread,
		&i.ExchangeRateValidFrom,
		&i.ExchangeRateValidUntil,
		&i.AccountLevelValidFrom,
		&i.AccountLevelValidUntil,
		&i.ExchangeRateID,
		&i.AccountLevelRateID,
		&i.CalculatedDiscountAmount,
		&i.IsBasedRate,
		&i.HasDiscount,
	)
	return i, err
}

const createAccountLevelExchangeRate = `-- name: CreateAccountLevelExchangeRate :one
INSERT INTO account_level_rates
(user_id, base_currency_id, quote_currency_id, rate, spread, valid_from, valid_until, type, automate_rate,
 rate_source,base_exchange_rate)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, user_id, base_currency_id, quote_currency_id, rate, spread, valid_from, valid_until, automate_rate, base_exchange_rate, rate_source, type, version
`

type CreateAccountLevelExchangeRateParams struct {
	UserID           uuid.UUID       `json:"user_id"`
	BaseCurrencyID   int32           `json:"base_currency_id"`
	QuoteCurrencyID  int32           `json:"quote_currency_id"`
	Rate             decimal.Decimal `json:"rate"`
	Spread           decimal.Decimal `json:"spread"`
	ValidFrom        sql.NullTime    `json:"valid_from"`
	ValidUntil       sql.NullTime    `json:"valid_until"`
	Type             string          `json:"type"`
	AutomateRate     bool            `json:"automate_rate"`
	RateSource       string          `json:"rate_source"`
	BaseExchangeRate int32           `json:"base_exchange_rate"`
}

func (q *Queries) CreateAccountLevelExchangeRate(ctx context.Context, arg CreateAccountLevelExchangeRateParams) (AccountLevelRate, error) {
	row := q.db.QueryRowContext(ctx, createAccountLevelExchangeRate,
		arg.UserID,
		arg.BaseCurrencyID,
		arg.QuoteCurrencyID,
		arg.Rate,
		arg.Spread,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.Type,
		arg.AutomateRate,
		arg.RateSource,
		arg.BaseExchangeRate,
	)
	var i AccountLevelRate
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BaseCurrencyID,
		&i.QuoteCurrencyID,
		&i.Rate,
		&i.Spread,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.AutomateRate,
		&i.BaseExchangeRate,
		&i.RateSource,
		&i.Type,
		&i.Version,
	)
	return i, err
}

const createAgentDailyDiscount = `-- name: CreateAgentDailyDiscount :one
INSERT INTO agent_daily_discounts
(user_id, base_currency_id, discount_amount, top_up_amount, start_timestamp, end_timestamp, discount_multiple)
VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, user_id, base_currency_id, discount_multiple, discount_amount, top_up_amount, start_timestamp, end_timestamp
`

type CreateAgentDailyDiscountParams struct {
	UserID           uuid.UUID       `json:"user_id"`
	BaseCurrencyID   int32           `json:"base_currency_id"`
	DiscountAmount   decimal.Decimal `json:"discount_amount"`
	TopUpAmount      decimal.Decimal `json:"top_up_amount"`
	StartTimestamp   sql.NullTime    `json:"start_timestamp"`
	EndTimestamp     sql.NullTime    `json:"end_timestamp"`
	DiscountMultiple decimal.Decimal `json:"discount_multiple"`
}

func (q *Queries) CreateAgentDailyDiscount(ctx context.Context, arg CreateAgentDailyDiscountParams) (AgentDailyDiscount, error) {
	row := q.db.QueryRowContext(ctx, createAgentDailyDiscount,
		arg.UserID,
		arg.BaseCurrencyID,
		arg.DiscountAmount,
		arg.TopUpAmount,
		arg.StartTimestamp,
		arg.EndTimestamp,
		arg.DiscountMultiple,
	)
	var i AgentDailyDiscount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BaseCurrencyID,
		&i.DiscountMultiple,
		&i.DiscountAmount,
		&i.TopUpAmount,
		&i.StartTimestamp,
		&i.EndTimestamp,
	)
	return i, err
}

const createExchangeRate = `-- name: CreateExchangeRate :one
INSERT INTO exchange_rates (
     base_currency_id,
     quote_currency_id,
     rate, spread,
     valid_from,
     valid_until,
     type,
     automate_rate,
     rate_source,
     base_exchange_rate
     )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id, base_currency_id, quote_currency_id, rate, spread, valid_from, valid_until, automate_rate, rate_source, base_exchange_rate, type, version
`

type CreateExchangeRateParams struct {
	BaseCurrencyID   int32           `json:"base_currency_id"`
	QuoteCurrencyID  int32           `json:"quote_currency_id"`
	Rate             decimal.Decimal `json:"rate"`
	Spread           decimal.Decimal `json:"spread"`
	ValidFrom        sql.NullTime    `json:"valid_from"`
	ValidUntil       sql.NullTime    `json:"valid_until"`
	Type             string          `json:"type"`
	AutomateRate     bool            `json:"automate_rate"`
	RateSource       string          `json:"rate_source"`
	BaseExchangeRate int32           `json:"base_exchange_rate"`
}

func (q *Queries) CreateExchangeRate(ctx context.Context, arg CreateExchangeRateParams) (ExchangeRate, error) {
	row := q.db.QueryRowContext(ctx, createExchangeRate,
		arg.BaseCurrencyID,
		arg.QuoteCurrencyID,
		arg.Rate,
		arg.Spread,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.Type,
		arg.AutomateRate,
		arg.RateSource,
		arg.BaseExchangeRate,
	)
	var i ExchangeRate
	err := row.Scan(
		&i.ID,
		&i.BaseCurrencyID,
		&i.QuoteCurrencyID,
		&i.Rate,
		&i.Spread,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.AutomateRate,
		&i.RateSource,
		&i.BaseExchangeRate,
		&i.Type,
		&i.Version,
	)
	return i, err
}

const deleteAccountLevelExchangeRate = `-- name: DeleteAccountLevelExchangeRate :exec
DELETE FROM account_level_rates WHERE id = $1
`

func (q *Queries) DeleteAccountLevelExchangeRate(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteAccountLevelExchangeRate, id)
	return err
}

const deleteAllAccountLevelExchangeRate = `-- name: DeleteAllAccountLevelExchangeRate :exec
DELETE FROM account_level_rates
`

func (q *Queries) DeleteAllAccountLevelExchangeRate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllAccountLevelExchangeRate)
	return err
}

const deleteAllAgentDailyDiscount = `-- name: DeleteAllAgentDailyDiscount :exec
DELETE FROM agent_daily_discounts
`

func (q *Queries) DeleteAllAgentDailyDiscount(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllAgentDailyDiscount)
	return err
}

const deleteAllExchangeRate = `-- name: DeleteAllExchangeRate :exec
DELETE FROM exchange_rates
`

func (q *Queries) DeleteAllExchangeRate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllExchangeRate)
	return err
}

const deleteExchangeRate = `-- name: DeleteExchangeRate :exec
DELETE FROM exchange_rates WHERE id = $1
`

func (q *Queries) DeleteExchangeRate(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteExchangeRate, id)
	return err
}

const getAccountLevelExchangeRate = `-- name: GetAccountLevelExchangeRate :one
SELECT id, user_id, base_currency_id, quote_currency_id, rate, spread, valid_from, valid_until, automate_rate, base_exchange_rate, rate_source, type, version
FROM account_level_rates
WHERE base_currency_id = $1
  AND quote_currency_id = $2
  AND type = $3
  AND user_id = $4
  AND valid_from <= now()
  AND (valid_until IS NULL OR valid_until > now())
ORDER BY valid_from DESC
LIMIT 1
`

type GetAccountLevelExchangeRateParams struct {
	BaseCurrencyID  int32     `json:"base_currency_id"`
	QuoteCurrencyID int32     `json:"quote_currency_id"`
	Type            string    `json:"type"`
	UserID          uuid.UUID `json:"user_id"`
}

func (q *Queries) GetAccountLevelExchangeRate(ctx context.Context, arg GetAccountLevelExchangeRateParams) (AccountLevelRate, error) {
	row := q.db.QueryRowContext(ctx, getAccountLevelExchangeRate,
		arg.BaseCurrencyID,
		arg.QuoteCurrencyID,
		arg.Type,
		arg.UserID,
	)
	var i AccountLevelRate
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BaseCurrencyID,
		&i.QuoteCurrencyID,
		&i.Rate,
		&i.Spread,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.AutomateRate,
		&i.BaseExchangeRate,
		&i.RateSource,
		&i.Type,
		&i.Version,
	)
	return i, err
}

const getAgentDailyDiscount = `-- name: GetAgentDailyDiscount :one
SELECT id, user_id, base_currency_id, discount_multiple, discount_amount, top_up_amount, start_timestamp, end_timestamp FROM agent_daily_discounts WHERE id = $1 AND user_id = $2 AND base_currency_id = $3
`

type GetAgentDailyDiscountParams struct {
	ID             int32     `json:"id"`
	UserID         uuid.UUID `json:"user_id"`
	BaseCurrencyID int32     `json:"base_currency_id"`
}

func (q *Queries) GetAgentDailyDiscount(ctx context.Context, arg GetAgentDailyDiscountParams) (AgentDailyDiscount, error) {
	row := q.db.QueryRowContext(ctx, getAgentDailyDiscount, arg.ID, arg.UserID, arg.BaseCurrencyID)
	var i AgentDailyDiscount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BaseCurrencyID,
		&i.DiscountMultiple,
		&i.DiscountAmount,
		&i.TopUpAmount,
		&i.StartTimestamp,
		&i.EndTimestamp,
	)
	return i, err
}

const getAllAutomatedExchangeRates = `-- name: GetAllAutomatedExchangeRates :many
SELECT id, base_currency_id, quote_currency_id, rate, spread, valid_from, valid_until, automate_rate, rate_source, base_exchange_rate, type, version FROM exchange_rates WHERE automate_rate = true
`

func (q *Queries) GetAllAutomatedExchangeRates(ctx context.Context) ([]ExchangeRate, error) {
	rows, err := q.db.QueryContext(ctx, getAllAutomatedExchangeRates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExchangeRate{}
	for rows.Next() {
		var i ExchangeRate
		if err := rows.Scan(
			&i.ID,
			&i.BaseCurrencyID,
			&i.QuoteCurrencyID,
			&i.Rate,
			&i.Spread,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.AutomateRate,
			&i.RateSource,
			&i.BaseExchangeRate,
			&i.Type,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAutomatedExchangeRatesThatAreDependencies = `-- name: GetAllAutomatedExchangeRatesThatAreDependencies :many
SELECT
    e.id, e.base_currency_id, e.quote_currency_id, e.rate, e.spread, e.valid_from, e.valid_until, e.automate_rate, e.rate_source, e.base_exchange_rate, e.type, e.version,
    base_currencies.code AS base_currency_code,
    quote_currencies.code AS quote_currency_code,
    CAST (concat(base_currencies.code, '/', quote_currencies.code) AS TEXT) AS currency_pair

FROM exchange_rates e
         JOIN currencies base_currencies ON e.base_currency_id = base_currencies.id
         JOIN currencies quote_currencies ON e.quote_currency_id = quote_currencies.id
WHERE e.id IN (
    SELECT DISTINCT base_exchange_rate
    FROM exchange_rates
    WHERE base_exchange_rate <> 0 AND automate_rate = true
) ORDER BY e.id ASC
`

type GetAllAutomatedExchangeRatesThatAreDependenciesRow struct {
	ID                int32           `json:"id"`
	BaseCurrencyID    int32           `json:"base_currency_id"`
	QuoteCurrencyID   int32           `json:"quote_currency_id"`
	Rate              decimal.Decimal `json:"rate"`
	Spread            decimal.Decimal `json:"spread"`
	ValidFrom         sql.NullTime    `json:"valid_from"`
	ValidUntil        sql.NullTime    `json:"valid_until"`
	AutomateRate      bool            `json:"automate_rate"`
	RateSource        string          `json:"rate_source"`
	BaseExchangeRate  int32           `json:"base_exchange_rate"`
	Type              string          `json:"type"`
	Version           time.Time       `json:"version"`
	BaseCurrencyCode  string          `json:"base_currency_code"`
	QuoteCurrencyCode string          `json:"quote_currency_code"`
	CurrencyPair      string          `json:"currency_pair"`
}

func (q *Queries) GetAllAutomatedExchangeRatesThatAreDependencies(ctx context.Context) ([]GetAllAutomatedExchangeRatesThatAreDependenciesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAutomatedExchangeRatesThatAreDependencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAutomatedExchangeRatesThatAreDependenciesRow{}
	for rows.Next() {
		var i GetAllAutomatedExchangeRatesThatAreDependenciesRow
		if err := rows.Scan(
			&i.ID,
			&i.BaseCurrencyID,
			&i.QuoteCurrencyID,
			&i.Rate,
			&i.Spread,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.AutomateRate,
			&i.RateSource,
			&i.BaseExchangeRate,
			&i.Type,
			&i.Version,
			&i.BaseCurrencyCode,
			&i.QuoteCurrencyCode,
			&i.CurrencyPair,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAutomatedExchangeRatesWithDependencies = `-- name: GetAllAutomatedExchangeRatesWithDependencies :many
SELECT
    e.id, e.base_currency_id, e.quote_currency_id, e.rate, e.spread, e.valid_from, e.valid_until, e.automate_rate, e.rate_source, e.base_exchange_rate, e.type, e.version,
    base_currencies.code AS base_currency_code,
    quote_currencies.code AS quote_currency_code,
    CAST (concat(base_currencies.code, '/', quote_currencies.code) AS TEXT) AS currency_pair
FROM exchange_rates e
         JOIN currencies base_currencies ON e.base_currency_id = base_currencies.id
         JOIN currencies quote_currencies ON e.quote_currency_id = quote_currencies.id
WHERE e.base_exchange_rate <> 0 AND e.automate_rate = true
`

type GetAllAutomatedExchangeRatesWithDependenciesRow struct {
	ID                int32           `json:"id"`
	BaseCurrencyID    int32           `json:"base_currency_id"`
	QuoteCurrencyID   int32           `json:"quote_currency_id"`
	Rate              decimal.Decimal `json:"rate"`
	Spread            decimal.Decimal `json:"spread"`
	ValidFrom         sql.NullTime    `json:"valid_from"`
	ValidUntil        sql.NullTime    `json:"valid_until"`
	AutomateRate      bool            `json:"automate_rate"`
	RateSource        string          `json:"rate_source"`
	BaseExchangeRate  int32           `json:"base_exchange_rate"`
	Type              string          `json:"type"`
	Version           time.Time       `json:"version"`
	BaseCurrencyCode  string          `json:"base_currency_code"`
	QuoteCurrencyCode string          `json:"quote_currency_code"`
	CurrencyPair      string          `json:"currency_pair"`
}

func (q *Queries) GetAllAutomatedExchangeRatesWithDependencies(ctx context.Context) ([]GetAllAutomatedExchangeRatesWithDependenciesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAutomatedExchangeRatesWithDependencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAutomatedExchangeRatesWithDependenciesRow{}
	for rows.Next() {
		var i GetAllAutomatedExchangeRatesWithDependenciesRow
		if err := rows.Scan(
			&i.ID,
			&i.BaseCurrencyID,
			&i.QuoteCurrencyID,
			&i.Rate,
			&i.Spread,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.AutomateRate,
			&i.RateSource,
			&i.BaseExchangeRate,
			&i.Type,
			&i.Version,
			&i.BaseCurrencyCode,
			&i.QuoteCurrencyCode,
			&i.CurrencyPair,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutoExchangeRatesByBaseCurrency = `-- name: GetAutoExchangeRatesByBaseCurrency :many
SELECT
    e.id, e.base_currency_id, e.quote_currency_id, e.rate, e.spread, e.valid_from, e.valid_until, e.automate_rate, e.rate_source, e.base_exchange_rate, e.type, e.version,
    base_currencies.code AS base_currency_code,
    quote_currencies.code AS quote_currency_code,
    CAST (concat(base_currencies.code, '/', quote_currencies.code) AS TEXT) AS currency_pair
FROM exchange_rates e
         JOIN currencies base_currencies ON e.base_currency_id = base_currencies.id
         JOIN currencies quote_currencies ON e.quote_currency_id = quote_currencies.id
WHERE e.base_currency_id = $1
  AND e.automate_rate = true AND e.type = $2
  AND (e.valid_from IS NULL OR e.valid_from <= now())
  AND (e.valid_until IS NULL OR e.valid_until > now())
`

type GetAutoExchangeRatesByBaseCurrencyParams struct {
	BaseCurrencyID int32  `json:"base_currency_id"`
	Type           string `json:"type"`
}

type GetAutoExchangeRatesByBaseCurrencyRow struct {
	ID                int32           `json:"id"`
	BaseCurrencyID    int32           `json:"base_currency_id"`
	QuoteCurrencyID   int32           `json:"quote_currency_id"`
	Rate              decimal.Decimal `json:"rate"`
	Spread            decimal.Decimal `json:"spread"`
	ValidFrom         sql.NullTime    `json:"valid_from"`
	ValidUntil        sql.NullTime    `json:"valid_until"`
	AutomateRate      bool            `json:"automate_rate"`
	RateSource        string          `json:"rate_source"`
	BaseExchangeRate  int32           `json:"base_exchange_rate"`
	Type              string          `json:"type"`
	Version           time.Time       `json:"version"`
	BaseCurrencyCode  string          `json:"base_currency_code"`
	QuoteCurrencyCode string          `json:"quote_currency_code"`
	CurrencyPair      string          `json:"currency_pair"`
}

func (q *Queries) GetAutoExchangeRatesByBaseCurrency(ctx context.Context, arg GetAutoExchangeRatesByBaseCurrencyParams) ([]GetAutoExchangeRatesByBaseCurrencyRow, error) {
	rows, err := q.db.QueryContext(ctx, getAutoExchangeRatesByBaseCurrency, arg.BaseCurrencyID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAutoExchangeRatesByBaseCurrencyRow{}
	for rows.Next() {
		var i GetAutoExchangeRatesByBaseCurrencyRow
		if err := rows.Scan(
			&i.ID,
			&i.BaseCurrencyID,
			&i.QuoteCurrencyID,
			&i.Rate,
			&i.Spread,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.AutomateRate,
			&i.RateSource,
			&i.BaseExchangeRate,
			&i.Type,
			&i.Version,
			&i.BaseCurrencyCode,
			&i.QuoteCurrencyCode,
			&i.CurrencyPair,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExchangeRate = `-- name: GetExchangeRate :one
SELECT id, base_currency_id, quote_currency_id, rate, spread, valid_from, valid_until, automate_rate, rate_source, base_exchange_rate, type, version
FROM exchange_rates
WHERE base_currency_id = $1
  AND quote_currency_id = $2
  AND type = $3
  AND valid_from <= now()
  AND (valid_until IS NULL OR valid_until > now())
ORDER BY valid_from DESC
LIMIT 1
`

type GetExchangeRateParams struct {
	BaseCurrencyID  int32  `json:"base_currency_id"`
	QuoteCurrencyID int32  `json:"quote_currency_id"`
	Type            string `json:"type"`
}

func (q *Queries) GetExchangeRate(ctx context.Context, arg GetExchangeRateParams) (ExchangeRate, error) {
	row := q.db.QueryRowContext(ctx, getExchangeRate, arg.BaseCurrencyID, arg.QuoteCurrencyID, arg.Type)
	var i ExchangeRate
	err := row.Scan(
		&i.ID,
		&i.BaseCurrencyID,
		&i.QuoteCurrencyID,
		&i.Rate,
		&i.Spread,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.AutomateRate,
		&i.RateSource,
		&i.BaseExchangeRate,
		&i.Type,
		&i.Version,
	)
	return i, err
}

const getExchangeRateByID = `-- name: GetExchangeRateByID :one
SELECT
    e.id, e.base_currency_id, e.quote_currency_id, e.rate, e.spread, e.valid_from, e.valid_until, e.automate_rate, e.rate_source, e.base_exchange_rate, e.type, e.version,
    base_currencies.code AS base_currency_code,
    quote_currencies.code AS quote_currency_code,
    CAST (concat(base_currencies.code, '/', quote_currencies.code) AS TEXT) AS currency_pair
FROM exchange_rates e
         JOIN currencies base_currencies ON e.base_currency_id = base_currencies.id
         JOIN currencies quote_currencies ON e.quote_currency_id = quote_currencies.id
WHERE e.id = $1
`

type GetExchangeRateByIDRow struct {
	ID                int32           `json:"id"`
	BaseCurrencyID    int32           `json:"base_currency_id"`
	QuoteCurrencyID   int32           `json:"quote_currency_id"`
	Rate              decimal.Decimal `json:"rate"`
	Spread            decimal.Decimal `json:"spread"`
	ValidFrom         sql.NullTime    `json:"valid_from"`
	ValidUntil        sql.NullTime    `json:"valid_until"`
	AutomateRate      bool            `json:"automate_rate"`
	RateSource        string          `json:"rate_source"`
	BaseExchangeRate  int32           `json:"base_exchange_rate"`
	Type              string          `json:"type"`
	Version           time.Time       `json:"version"`
	BaseCurrencyCode  string          `json:"base_currency_code"`
	QuoteCurrencyCode string          `json:"quote_currency_code"`
	CurrencyPair      string          `json:"currency_pair"`
}

func (q *Queries) GetExchangeRateByID(ctx context.Context, id int32) (GetExchangeRateByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getExchangeRateByID, id)
	var i GetExchangeRateByIDRow
	err := row.Scan(
		&i.ID,
		&i.BaseCurrencyID,
		&i.QuoteCurrencyID,
		&i.Rate,
		&i.Spread,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.AutomateRate,
		&i.RateSource,
		&i.BaseExchangeRate,
		&i.Type,
		&i.Version,
		&i.BaseCurrencyCode,
		&i.QuoteCurrencyCode,
		&i.CurrencyPair,
	)
	return i, err
}

const getExchangeRateByPeerType = `-- name: GetExchangeRateByPeerType :one
SELECT
    e.id, e.base_currency_id, e.quote_currency_id, e.rate, e.spread, e.valid_from, e.valid_until, e.automate_rate, e.rate_source, e.base_exchange_rate, e.type, e.version,
    base_currencies.code AS base_currency_code,
    quote_currencies.code AS quote_currency_code,
    CAST (concat(base_currencies.code, '/', quote_currencies.code) AS TEXT) AS currency_pair
FROM exchange_rates e
         JOIN currencies base_currencies ON e.base_currency_id = base_currencies.id
         JOIN currencies quote_currencies ON e.quote_currency_id = quote_currencies.id
WHERE concat(base_currencies.code, '/', quote_currencies.code) = $1 AND e.type = $2
`

type GetExchangeRateByPeerTypeParams struct {
	Code string `json:"code"`
	Type string `json:"type"`
}

type GetExchangeRateByPeerTypeRow struct {
	ID                int32           `json:"id"`
	BaseCurrencyID    int32           `json:"base_currency_id"`
	QuoteCurrencyID   int32           `json:"quote_currency_id"`
	Rate              decimal.Decimal `json:"rate"`
	Spread            decimal.Decimal `json:"spread"`
	ValidFrom         sql.NullTime    `json:"valid_from"`
	ValidUntil        sql.NullTime    `json:"valid_until"`
	AutomateRate      bool            `json:"automate_rate"`
	RateSource        string          `json:"rate_source"`
	BaseExchangeRate  int32           `json:"base_exchange_rate"`
	Type              string          `json:"type"`
	Version           time.Time       `json:"version"`
	BaseCurrencyCode  string          `json:"base_currency_code"`
	QuoteCurrencyCode string          `json:"quote_currency_code"`
	CurrencyPair      string          `json:"currency_pair"`
}

func (q *Queries) GetExchangeRateByPeerType(ctx context.Context, arg GetExchangeRateByPeerTypeParams) (GetExchangeRateByPeerTypeRow, error) {
	row := q.db.QueryRowContext(ctx, getExchangeRateByPeerType, arg.Code, arg.Type)
	var i GetExchangeRateByPeerTypeRow
	err := row.Scan(
		&i.ID,
		&i.BaseCurrencyID,
		&i.QuoteCurrencyID,
		&i.Rate,
		&i.Spread,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.AutomateRate,
		&i.RateSource,
		&i.BaseExchangeRate,
		&i.Type,
		&i.Version,
		&i.BaseCurrencyCode,
		&i.QuoteCurrencyCode,
		&i.CurrencyPair,
	)
	return i, err
}

const getExchangeRatePeer = `-- name: GetExchangeRatePeer :one
SELECT
    e.id, e.base_currency_id, e.quote_currency_id, e.rate, e.spread, e.valid_from, e.valid_until, e.automate_rate, e.rate_source, e.base_exchange_rate, e.type, e.version,
    base_currencies.code AS base_currency_code,
    quote_currencies.code AS quote_currency_code,
    CAST (concat(base_currencies.code, '/', quote_currencies.code) AS TEXT) AS currency_pair
FROM exchange_rates e
         JOIN currencies base_currencies ON e.base_currency_id = base_currencies.id
         JOIN currencies quote_currencies ON e.quote_currency_id = quote_currencies.id
WHERE e.base_currency_id = $1 and e.quote_currency_id = $2 and e.type = $3
`

type GetExchangeRatePeerParams struct {
	BaseCurrencyID  int32  `json:"base_currency_id"`
	QuoteCurrencyID int32  `json:"quote_currency_id"`
	Type            string `json:"type"`
}

type GetExchangeRatePeerRow struct {
	ID                int32           `json:"id"`
	BaseCurrencyID    int32           `json:"base_currency_id"`
	QuoteCurrencyID   int32           `json:"quote_currency_id"`
	Rate              decimal.Decimal `json:"rate"`
	Spread            decimal.Decimal `json:"spread"`
	ValidFrom         sql.NullTime    `json:"valid_from"`
	ValidUntil        sql.NullTime    `json:"valid_until"`
	AutomateRate      bool            `json:"automate_rate"`
	RateSource        string          `json:"rate_source"`
	BaseExchangeRate  int32           `json:"base_exchange_rate"`
	Type              string          `json:"type"`
	Version           time.Time       `json:"version"`
	BaseCurrencyCode  string          `json:"base_currency_code"`
	QuoteCurrencyCode string          `json:"quote_currency_code"`
	CurrencyPair      string          `json:"currency_pair"`
}

func (q *Queries) GetExchangeRatePeer(ctx context.Context, arg GetExchangeRatePeerParams) (GetExchangeRatePeerRow, error) {
	row := q.db.QueryRowContext(ctx, getExchangeRatePeer, arg.BaseCurrencyID, arg.QuoteCurrencyID, arg.Type)
	var i GetExchangeRatePeerRow
	err := row.Scan(
		&i.ID,
		&i.BaseCurrencyID,
		&i.QuoteCurrencyID,
		&i.Rate,
		&i.Spread,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.AutomateRate,
		&i.RateSource,
		&i.BaseExchangeRate,
		&i.Type,
		&i.Version,
		&i.BaseCurrencyCode,
		&i.QuoteCurrencyCode,
		&i.CurrencyPair,
	)
	return i, err
}

const updateAccountLevelExchangeRate = `-- name: UpdateAccountLevelExchangeRate :one
UPDATE account_level_rates
SET base_currency_id = COALESCE($1, base_currency_id),
    quote_currency_id = COALESCE($2, quote_currency_id),
    rate = COALESCE($3, rate),
    spread = COALESCE($4, spread),
    valid_from = COALESCE($5, valid_from),
    user_id = COALESCE($6, user_id),
    valid_until = COALESCE($7, valid_until),
    type = COALESCE($8, type),
    automate_rate = COALESCE($9, automate_rate),
    rate_source = COALESCE($10, rate_source),
    base_exchange_rate = COALESCE($11, base_exchange_rate),
    version = NOW()
WHERE id = $12 RETURNING id, user_id, base_currency_id, quote_currency_id, rate, spread, valid_from, valid_until, automate_rate, base_exchange_rate, rate_source, type, version
`

type UpdateAccountLevelExchangeRateParams struct {
	BaseCurrencyID   sql.NullInt32   `json:"base_currency_id"`
	QuoteCurrencyID  sql.NullInt32   `json:"quote_currency_id"`
	Rate             decimal.Decimal `json:"rate"`
	Spread           decimal.Decimal `json:"spread"`
	ValidFrom        sql.NullTime    `json:"valid_from"`
	UserID           uuid.NullUUID   `json:"user_id"`
	ValidUntil       sql.NullTime    `json:"valid_until"`
	Type             sql.NullString  `json:"type"`
	AutomateRate     sql.NullBool    `json:"automate_rate"`
	RateSource       sql.NullString  `json:"rate_source"`
	BaseExchangeRate sql.NullInt32   `json:"base_exchange_rate"`
	ID               int32           `json:"id"`
}

func (q *Queries) UpdateAccountLevelExchangeRate(ctx context.Context, arg UpdateAccountLevelExchangeRateParams) (AccountLevelRate, error) {
	row := q.db.QueryRowContext(ctx, updateAccountLevelExchangeRate,
		arg.BaseCurrencyID,
		arg.QuoteCurrencyID,
		arg.Rate,
		arg.Spread,
		arg.ValidFrom,
		arg.UserID,
		arg.ValidUntil,
		arg.Type,
		arg.AutomateRate,
		arg.RateSource,
		arg.BaseExchangeRate,
		arg.ID,
	)
	var i AccountLevelRate
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BaseCurrencyID,
		&i.QuoteCurrencyID,
		&i.Rate,
		&i.Spread,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.AutomateRate,
		&i.BaseExchangeRate,
		&i.RateSource,
		&i.Type,
		&i.Version,
	)
	return i, err
}

const updateExchangeRate = `-- name: UpdateExchangeRate :one
UPDATE exchange_rates
SET base_currency_id = COALESCE($1, base_currency_id),
    quote_currency_id = COALESCE($2, quote_currency_id),
    rate = COALESCE($3, rate),
    spread = COALESCE($4, spread),
    valid_from = COALESCE($5, valid_from),
    valid_until = COALESCE($6, valid_until),
    type = COALESCE($7, type),
    automate_rate = COALESCE($8, automate_rate),
    rate_source = COALESCE($9, rate_source),
    base_exchange_rate = COALESCE($10, base_exchange_rate),
    version = NOW()
WHERE id = $11 RETURNING id, base_currency_id, quote_currency_id, rate, spread, valid_from, valid_until, automate_rate, rate_source, base_exchange_rate, type, version
`

type UpdateExchangeRateParams struct {
	BaseCurrencyID   sql.NullInt32   `json:"base_currency_id"`
	QuoteCurrencyID  sql.NullInt32   `json:"quote_currency_id"`
	Rate             decimal.Decimal `json:"rate"`
	Spread           decimal.Decimal `json:"spread"`
	ValidFrom        sql.NullTime    `json:"valid_from"`
	ValidUntil       sql.NullTime    `json:"valid_until"`
	Type             sql.NullString  `json:"type"`
	AutomateRate     sql.NullBool    `json:"automate_rate"`
	RateSource       sql.NullString  `json:"rate_source"`
	BaseExchangeRate sql.NullInt32   `json:"base_exchange_rate"`
	ID               int32           `json:"id"`
}

func (q *Queries) UpdateExchangeRate(ctx context.Context, arg UpdateExchangeRateParams) (ExchangeRate, error) {
	row := q.db.QueryRowContext(ctx, updateExchangeRate,
		arg.BaseCurrencyID,
		arg.QuoteCurrencyID,
		arg.Rate,
		arg.Spread,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.Type,
		arg.AutomateRate,
		arg.RateSource,
		arg.BaseExchangeRate,
		arg.ID,
	)
	var i ExchangeRate
	err := row.Scan(
		&i.ID,
		&i.BaseCurrencyID,
		&i.QuoteCurrencyID,
		&i.Rate,
		&i.Spread,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.AutomateRate,
		&i.RateSource,
		&i.BaseExchangeRate,
		&i.Type,
		&i.Version,
	)
	return i, err
}

const validateAccountLevelExchangeRateExistence = `-- name: ValidateAccountLevelExchangeRateExistence :one
SELECT COUNT(*) as count
FROM account_level_rates AS main_rates
WHERE
        main_rates.user_id = $3
  AND (
        (main_rates.base_currency_id = $2 AND main_rates.quote_currency_id = $1)
        OR
        (
            main_rates.base_currency_id = $1 AND main_rates.quote_currency_id = $2 AND
            main_rates.type = $4 AND EXISTS
                (SELECT 1 FROM account_level_rates sub_rates WHERE sub_rates.base_currency_id = main_rates.base_currency_id
           AND sub_rates.quote_currency_id = main_rates.quote_currency_id AND sub_rates.user_id = main_rates.user_id
           AND sub_rates.type = main_rates.type))
)
  AND main_rates.valid_from <= now()
  AND (main_rates.valid_until IS NULL OR main_rates.valid_until > now())
`

type ValidateAccountLevelExchangeRateExistenceParams struct {
	QuoteCurrencyID int32     `json:"quote_currency_id"`
	BaseCurrencyID  int32     `json:"base_currency_id"`
	UserID          uuid.UUID `json:"user_id"`
	Type            string    `json:"type"`
}

func (q *Queries) ValidateAccountLevelExchangeRateExistence(ctx context.Context, arg ValidateAccountLevelExchangeRateExistenceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, validateAccountLevelExchangeRateExistence,
		arg.QuoteCurrencyID,
		arg.BaseCurrencyID,
		arg.UserID,
		arg.Type,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const validateExchangeRateExistence = `-- name: ValidateExchangeRateExistence :one
SELECT COUNT(*) as count
FROM exchange_rates
WHERE
    (base_currency_id = $2 AND quote_currency_id = $1)
  AND type = $3
  AND valid_from <= now()
  AND (valid_until IS NULL OR valid_until > now())
`

type ValidateExchangeRateExistenceParams struct {
	QuoteCurrencyID int32  `json:"quote_currency_id"`
	BaseCurrencyID  int32  `json:"base_currency_id"`
	Type            string `json:"type"`
}

func (q *Queries) ValidateExchangeRateExistence(ctx context.Context, arg ValidateExchangeRateExistenceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, validateExchangeRateExistence, arg.QuoteCurrencyID, arg.BaseCurrencyID, arg.Type)
	var count int64
	err := row.Scan(&count)
	return count, err
}
