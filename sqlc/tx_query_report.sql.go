// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: tx_query_report.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const reportGetTransactionInfo = `-- name: ReportGetTransactionInfo :many
SELECT
    u.email,
    CAST(t.amount AS numeric) AS amount,
    t.created_at,
    t.source,
    CAST(t.fees_amount AS numeric) AS fees_amount,
    t.fees_is_percentage,
    t.payment_method,
    t.type,
    t.action,
    t.status,
    t.tag,
    CAST(t.rate AS numeric) AS rate,
    t.wallet_id,
    t.id as trans_id,
    t.payload,
    c.code as currency
FROM
    transactions t
        JOIN
    users u ON t.user_id = u.id
        JOIN
    currencies c ON t.currency_id = c.id
ORDER BY
    u.email, t.created_at DESC
`

type ReportGetTransactionInfoRow struct {
	Email            string          `json:"email"`
	Amount           decimal.Decimal `json:"amount"`
	CreatedAt        time.Time       `json:"created_at"`
	Source           string          `json:"source"`
	FeesAmount       decimal.Decimal `json:"fees_amount"`
	FeesIsPercentage bool            `json:"fees_is_percentage"`
	PaymentMethod    string          `json:"payment_method"`
	Type             string          `json:"type"`
	Action           string          `json:"action"`
	Status           string          `json:"status"`
	Tag              string          `json:"tag"`
	Rate             decimal.Decimal `json:"rate"`
	WalletID         uuid.UUID       `json:"wallet_id"`
	TransID          uuid.UUID       `json:"trans_id"`
	Payload          json.RawMessage `json:"payload"`
	Currency         string          `json:"currency"`
}

func (q *Queries) ReportGetTransactionInfo(ctx context.Context) ([]ReportGetTransactionInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, reportGetTransactionInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportGetTransactionInfoRow{}
	for rows.Next() {
		var i ReportGetTransactionInfoRow
		if err := rows.Scan(
			&i.Email,
			&i.Amount,
			&i.CreatedAt,
			&i.Source,
			&i.FeesAmount,
			&i.FeesIsPercentage,
			&i.PaymentMethod,
			&i.Type,
			&i.Action,
			&i.Status,
			&i.Tag,
			&i.Rate,
			&i.WalletID,
			&i.TransID,
			&i.Payload,
			&i.Currency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reportGetWalletBalances = `-- name: ReportGetWalletBalances :many
SELECT
    u.email,
    cu.code,
    CAST(SUM(w.balance) AS numeric) AS total_balance,
    w.id as w_id
FROM
    wallets w
        JOIN
    users u ON w.user_id = u.id
        JOIN
    currencies cu ON w.currency_id = cu.id
GROUP BY
    u.email,
    cu.code,
    w.id
ORDER BY
    u.email
`

type ReportGetWalletBalancesRow struct {
	Email        string          `json:"email"`
	Code         string          `json:"code"`
	TotalBalance decimal.Decimal `json:"total_balance"`
	WID          uuid.UUID       `json:"w_id"`
}

func (q *Queries) ReportGetWalletBalances(ctx context.Context) ([]ReportGetWalletBalancesRow, error) {
	rows, err := q.db.QueryContext(ctx, reportGetWalletBalances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportGetWalletBalancesRow{}
	for rows.Next() {
		var i ReportGetWalletBalancesRow
		if err := rows.Scan(
			&i.Email,
			&i.Code,
			&i.TotalBalance,
			&i.WID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
